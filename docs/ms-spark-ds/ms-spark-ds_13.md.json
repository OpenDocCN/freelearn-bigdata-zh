["```scala\ndrwxr-xr-x 6 mrh mygroup 204 16 Jun 2015 resources\n\n```", "```scala\n-rwx---rwx 6 mrh mygroup 204 16 Jun 2015 secretFile.txt\n\n```", "```scala\n-rwxr----- 6 mrh mygroup 204 16 Jun 2015 secretFile.txt\n\n```", "```scala\nhdfs dfs -chmod 777 /path/to/my/file.txt\n\n```", "```scala\nsaveAsTextFile(filePath, Class<? extends\n\u00a0\u00a0\u00a0\u00a0 org.apache.hadoop.io.compress.CompressionCodec> codec)\n```", "```scala\nimport org.apache.hadoop.io.compress.crypto.CryptoCompressor;\nimport org.apache.hadoop.io.compress.crypto.CryptoDecompressor;\n\npublic class CryptoCodec implements CompressionCodec, Configurable {\n\n\u00a0\u00a0\u00a0 public static final String CRYPTO_DEFAULT_EXT = \".crypto\";\n\u00a0\u00a0\u00a0 private Configuration config;\n\n\u00a0\u00a0\u00a0 @Override\n\u00a0\u00a0\u00a0 public Compressor createCompressor() {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return new CryptoCompressor();\n\u00a0\u00a0\u00a0 }\n\u00a0\u00a0\u00a0 @Override\n\u00a0\u00a0\u00a0 public Decompressor createDecompressor() {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return new CryptoDecompressor();\n\u00a0\u00a0\u00a0 }\n\u00a0\u00a0\u00a0 @Override\n\u00a0\u00a0\u00a0 public CompressionInputStream createInputStream(InputStream in)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 throws IOException {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return createInputStream(in, createDecompressor());\n\u00a0\u00a0\u00a0 }\n\u00a0\u00a0\u00a0 @Override\n\u00a0\u00a0\u00a0 public CompressionInputStream createInputStream(InputStream in,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Decompressor decomp) throws IOException {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return new DecompressorStream(in, decomp);\n\u00a0\u00a0\u00a0 }\n\u00a0\u00a0\u00a0 @Override\n\u00a0\u00a0\u00a0 public CompressionOutputStream createOutputStream(OutputStream out)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 throws IOException {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return createOutputStream(out, createCompressor());\n\u00a0\u00a0\u00a0 }\n\u00a0\u00a0\u00a0 @Override\n\u00a0\u00a0\u00a0 public CompressionOutputStream createOutputStream(OutputStream out,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Compressor comp) throws IOException {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return new CompressorStream(out, comp);\n\u00a0\u00a0\u00a0 }\n\u00a0\u00a0\u00a0 @Override\n\u00a0\u00a0\u00a0 public Class<? extends Compressor> getCompressorType() {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return CryptoCompressor.class;\n\u00a0\u00a0\u00a0 }\n\u00a0\u00a0\u00a0 @Override\n\u00a0\u00a0\u00a0 public Class<? extends Decompressor> getDecompressorType() {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return CryptoDecompressor.class;\n\u00a0\u00a0\u00a0 }\n\u00a0\u00a0\u00a0 @Override\n\u00a0\u00a0\u00a0 public String getDefaultExtension() {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return CRYPTO_DEFAULT_EXT;\n\u00a0\u00a0\u00a0 }\n\u00a0\u00a0\u00a0 @Override\n\u00a0\u00a0\u00a0 public Configuration getConf() {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return this.config;\n\u00a0\u00a0\u00a0 }\n\u00a0\u00a0\u00a0 @Override\n\u00a0\u00a0\u00a0 public void setConf(Configuration config) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 this.config = config;\n\u00a0\u00a0\u00a0 }\n}\n```", "```scala\npublic CryptoCompressor() { \n    crypto = new EncryptionUtils(); } \n\n```", "```scala\npublic EncryptionUtils() {\n\u00a0\u00a0\u00a0 this.setupCrypto(getPassword());\n}\n\nprivate String getPassword() {\n\u00a0\u00a0\u00a0 // Use a Java KeyStore as per the below code, a Database or any other secure mechanism to obtain a password\n\u00a0\u00a0\u00a0 // TODO We will return a hard coded String for simplicity\n\u00a0\u00a0\u00a0 return \"keystorepassword\";\n}\n\nprivate void setupCrypto(String password) {\n\u00a0\u00a0\u00a0 IvParameterSpec paramSpec = new IvParameterSpec(generateIV());\n\u00a0\u00a0\u00a0 skeySpec = new SecretKeySpec(password.getBytes(\"UTF-8\"), \"AES\");\n\u00a0\u00a0\u00a0 ecipher = Cipher.getInstance(encoding);\n\u00a0\u00a0\u00a0 ecipher.init(Cipher.ENCRYPT_MODE, skeySpec, paramSpec);\n\u00a0\u00a0\u00a0 dcipher = Cipher.getInstance(encoding);\n}\n\nprivate byte[] generateIV() {\n\u00a0\u00a0\u00a0 SecureRandom random = new SecureRandom();\n\u00a0\u00a0\u00a0 byte bytes[] = new byte[16];\n\u00a0\u00a0\u00a0 random.nextBytes(bytes);\n\u00a0\u00a0\u00a0 return bytes;\n}\n\n```", "```scala\npublic byte[] encrypt(byte[] plainBytes, boolean addIV)\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 throws InvalidAlgorithmParameterException,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 InvalidKeyException {\n\n\u00a0\u00a0\u00a0 byte[] iv = \"\".getBytes(\"UTF-8\");\n\u00a0\u00a0\u00a0 if (!addIV) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 iv = ecipher.getParameters()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 .getParameterSpec(IvParameterSpec.class)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 .getIV();\n\u00a0\u00a0\u00a0 }\n\u00a0\u00a0\u00a0 byte[] ciphertext = ecipher.update(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 plainBytes, 0, plainBytes.length);\n\u00a0\u00a0\u00a0 byte[] result = new byte[iv.length + ciphertext.length];\n\u00a0\u00a0\u00a0 System.arraycopy(iv, 0, result, 0, iv.length);\n\u00a0\u00a0\u00a0 System.arraycopy(ciphertext, 0,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 result, iv.length, ciphertext.length);\n\u00a0\u00a0\u00a0 return result;\n}\n\npublic byte[] decrypt(byte[] ciphertext, boolean useIV)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 throws InvalidAlgorithmParameterException,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 InvalidKeyException {\n\n\u00a0\u00a0\u00a0 byte[] deciphered;\n\u00a0\u00a0\u00a0 if (useIV) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 byte[] iv = Arrays.copyOfRange(ciphertext, 0, 16);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 IvParameterSpec paramSpec = new IvParameterSpec(iv);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 dcipher.init(Cipher.DECRYPT_MODE, skeySpec, paramSpec);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 deciphered = dcipher.update(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 ciphertext, 16, ciphertext.length - 16);\n\u00a0\u00a0\u00a0 } else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 deciphered = dcipher.update(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 ciphertext, 0, ciphertext.length);\n\u00a0\u00a0\u00a0 }\n\u00a0\u00a0\u00a0 return deciphered;\n\n}\n\npublic byte[] doFinal() {\n\u00a0\u00a0\u00a0 try {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 byte[] ciphertext = ecipher.doFinal();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return ciphertext;\n\u00a0\u00a0\u00a0 } catch (Exception e) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 log.error(e.getStackTrace());\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return null;\n\u00a0\u00a0\u00a0 }\n}\n```", "```scala\n@Override\npublic synchronized int compress(byte[] buf, int off, int len) throws IOException {\n \u00a0\u00a0 finished = false;\n \u00a0\u00a0 if (remain != null && remain.remaining() > 0) {\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 int size = Math.min(len, remain.remaining());\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 remain.get(buf, off, size);\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 wrote += size;\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if (!remain.hasRemaining()) {\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 remain = null;\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 setFinished();\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 }\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return size;\n \u00a0\u00a0 }\n \u00a0\u00a0 if (in == null || in.remaining() <= 0) {\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 setFinished();\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return 0;\n \u00a0\u00a0 }\n \u00a0\u00a0 byte[] w = new byte[in.remaining()];\n \u00a0 \u00a0in.get(w);\n \u00a0\u00a0 byte[] b = crypto.encrypt(w, addedIV);\n \u00a0\u00a0 if (!addedIV)\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 addedIV = true;\n \u00a0\u00a0 int size = Math.min(len, b.length);\n \u00a0\u00a0 remain = ByteBuffer.wrap(b);\n \u00a0\u00a0 remain.get(buf, off, size);\n \u00a0\u00a0 wrote += size;\n \u00a0\u00a0 if (remain.remaining() <= 0)\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 setFinished();\n \u00a0\u00a0 return size;\n}\n\n```", "```scala\nval conf = new SparkConf() \nval sc = new SparkContext(conf.setAppName(\"crypto encrypt\")) \nval writeRDD = sc.parallelize(List(1, 2, 3, 4), 2) \nwriteRDD.saveAsTextFile(\"file:///encrypted/data/path\",classOf[CryptoCodec]) \n\n```", "```scala\nval conf = new SparkConf() \nconf.set(\"spark.hadoop.io.compression.codecs\", \n         \"org.apache.hadoop.io.compress.CryptoCodec\") \nval sc = new SparkContext(conf.setAppName(\"crypto decrypt\")) \nval readRDD = sc.textFile(\"file:///encrypted/data/path\") \nreadRDD.collect().foreach(println) \n\n```", "```scala\npublic static void createJceksStoreAddKey() {\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 KeyStore keyStore = KeyStore.getInstance(\"JCEKS\");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 keyStore.load(null, null);\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 KeyGenerator kg = KeyGenerator.getInstance(\"AES\");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 kg.init(128); // 16 bytes = 128 bit\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 SecretKey sk = kg.generateKey();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 System.out.println(sk.getEncoded().toString());\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 keyStore.setKeyEntry(\"secretKeyAlias\", sk,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \"keystorepassword\".toCharArray(), null);\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 keyStore.store(new FileOutputStream(\"keystore.jceks\"),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \"keystorepassword\".toCharArray());\n}\n```", "```scala\nkeytool -genseckey-alias secretKeyAlias /\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 -keyalg AES /\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 -keystore keystore.jceks /\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 -keysize 128 /\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 -storeType JCEKS\n\n```", "```scala\nkeytool -v -list -storetype JCEKS -keystore keystore.jceks\n\n```", "```scala\npublic static SecretKey retrieveKey()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 throws KeyStoreException,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 IOException,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 CertificateException,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 NoSuchAlgorithmException,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 UnrecoverableKeyException {\n\n\u00a0\u00a0\u00a0 KeyStore keyStore = KeyStore.getInstance(\"JCEKS\");\n\u00a0\u00a0\u00a0 keyStore.load(new FileInputStream(\"keystore.jceks\"),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \"keystorepassword\".toCharArray());\n\n\u00a0\u00a0\u00a0 SecretKey key = (SecretKey) keyStore.getKey(\"secretKeyAlias\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \"keystorepassword\".toCharArray());\n\n\u00a0\u00a0\u00a0 System.out.println(key.getEncoded().toString());\n\u00a0\u00a0\u00a0 return key;\n}\n```", "```scala\nprivate String getPassword(){\n\u00a0\u00a0\u00a0 return retrieveKey();\n}\n```", "```scala\n            John,Smith,3 New Road,London,E1 2AA,0207 123456,4659 4234 5678 \n            9999\n    ```", "```scala\n            John,XXXXXX,X New Road,London,XX 2AA,XXXX 123456,4659 \n            XXXXXXXXXXXXXX\n    ```", "```scala\nobject RecordField extends Enumeration {\n\u00a0type Obfuscation = Value\n\u00a0val FIRSTNAME\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0 = Value(0, \"\")\n\u00a0val SURNAME\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0 = Value(1, \"0,len\")\n\u00a0val ADDRESS1\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0 = Value(2, \"0,1\")\n\u00a0val ADDRESS2 \u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0 = Value(3, \"\")\n\u00a0val POSTCODE\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0 = Value(4, \"prefix\")\n\u00a0val TELNUMBER \u00a0\u00a0\u00a0\u00a0\u00a0 = Value(5, \"prefix\")\n\u00a0val CCNUMBER\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0 = Value(6, \"suffix\")\n}\n```", "```scala\ndef getObfuscationResult(text: String): String = {\n \u00a0 text\n \u00a0\u00a0 .split(\",\")\n \u00a0\u00a0 .zipWithIndex\n \u00a0\u00a0 .map { case (field, idx) =>\n \u00a0\u00a0\u00a0\u00a0 field match {\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case s: String if idx >= 0 && idx <= 6 => \n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 stringObfuscator(s,RecordField(idx).toString, 'X')\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 case _ => \"Unknown field\"\n \u00a0\u00a0\u00a0\u00a0 }\n \u00a0\u00a0 }\n \u00a0\u00a0 .mkString(\",\")\n }\n```", "```scala\ndef stringObfuscator(text: String,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 maskArgs: String,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 maskChar: Char):String = {\n\u00a0var start = 0\n\u00a0var end = 0\n\n\u00a0if (maskArgs.equals(\"\")) {\n\u00a0\u00a0 text\n\u00a0}\n\n\u00a0if (maskArgs.contains(\",\")) {\n\u00a0\u00a0 start = maskArgs.split(',')(0).toInt\n\u00a0\u00a0 if (maskArgs.split(',')(1) == \"len\")\n\u00a0\u00a0\u00a0\u00a0 end = text.length\n\u00a0\u00a0 else\n\u00a0\u00a0\u00a0\u00a0 end = maskArgs.split(',')(1).toInt\n\u00a0}\n\n\u00a0if (maskArgs.contains(\"prefix\")){\n\u00a0\u00a0 end = text.indexOf(\" \")\n\u00a0}\n\n\u00a0if (maskArgs.contains(\"suffix\")){\n\u00a0\u00a0 start = text.indexOf(\" \") + 1\n\u00a0\u00a0 end = text.length\n\u00a0}\n\n\u00a0if (start > end)\n\u00a0\u00a0 maskChar\n\n\u00a0val maskLength: Int = end - start\n\n\u00a0if (maskLength == 0)\n\u00a0\u00a0 text\n\n\u00a0var sbMasked: StringBuilder\u00a0 = new StringBuilder(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 text.substring(0, start))\n\n\u00a0for(i <- 1 to maskLength) {\n\u00a0\u00a0 sbMasked.append(maskChar)\n\u00a0}\n\u00a0sbMasked.append(text.substring(start + maskLength)).toString\n}\n```", "```scala\ngetObfuscationResult(\n\u00a0 \"John,Smith,3 New Road,London,E1 2AA,0207 123456,4659 4234 5678 9999\")\n```", "```scala\nJohn,XXXXXX,X New Road,London,XX 2AA,XXXX 123456,4659 XXXXXXXXXXXXXX\n\n```", "```scala\nval ADDRESS1 = Value(2, \"0,1;2,len\")\n\n```", "```scala\nSimon,Jones,2 The Mall,London,NW1 2JT,0171 123890,1545 3146 6273 6262\n```", "```scala\nval forenames = Array(\"John\",\"Fred\",\"Jack\",\"Simon\")\nval surnames = Array(\"Smith\",\"Jones\",\"Hall\",\"West\")\nval streets = Array(\"17 Bound Mews\",\"76 Byron Place\",\n\u00a0\u00a0\u00a0 \"2 The Mall\",\"51 St James\")\n```", "```scala\nval composite = Array(\"London,NW1 2JT,0171 123890\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \"Newcastle, N23 2FD,0191 567000\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \"Bristol,BS1 2AA,0117 934098\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \"Manchester,M56 9JH,0121 111672\")\n```", "```scala\ndef getMaskedResult(): String = {\n\n\u00a0 Array(\n\u00a0\u00a0\u00a0 forenames(scala.util.Random.nextInt(forenames.length)),\n\u00a0\u00a0\u00a0 surnames(scala.util.Random.nextInt(surnames.length)),\n\u00a0\u00a0\u00a0 streets(scala.util.Random.nextInt(streets.length)),\n\u00a0\u00a0\u00a0 composite(scala.util.Random.nextInt(composite.length)).split(\",\"),\n\u00a0\u00a0\u00a0 RandomCCNumber)\n\u00a0 .flatMap {\n\u00a0\u00a0\u00a0 case s:String => Seq(s)\n\u00a0\u00a0\u00a0 case a:Array[String] => a\n\u00a0 }\n\u00a0 .mkString(\",\")\n}\n```", "```scala\ndef RandomCCNumber(): String = {\n\n\u00a0\u00a0\u00a0 def appendDigits(ccn:Array[String]): Array[String] = {\n \u00a0\u00a0\u00a0\u00a0\u00a0 if (ccn.length < 4) {\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 appendDigits(ccn :+ (for (i <- 1 to 4) \n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 yield scala.util.Random.nextInt(9)).mkString)\n \u00a0\u00a0\u00a0\u00a0\u00a0 }\n \u00a0\u00a0\u00a0\u00a0\u00a0 else {\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 ccn\n \u00a0\u00a0\u00a0\u00a0\u00a0 }\n \u00a0\u00a0\u00a0 }\n \u00a0\u00a0\u00a0 appendDigits(Array()).mkString(\" \")\n}\n```", "```scala\ngetMaskedResult(\n\u00a0 \"John,Smith,3 New Road,London,E1 2AA,0207 123456,4659 4234 5678 9999\")\n```", "```scala\nJack,Hall,76 Byron Place,Newcastle, N23 2FD,0191 567000,7533 8606 6465 6040\n```", "```scala\nJohn,West,2 The Mall,Manchester,M56 9JH,0121 111672,3884 0242 3212 4704\n```", "```scala\n John,Smith,[25AJZ99P],[78OPL45K],[72GRT55N],[54CPW59D],[32DOI01F]\n```", "```scala\nval uuid: String = java.util.UUID.randomUUID.toString\nval rowID: Text = new Text(\"[\" + uuid + \"]\")\nval colFam: Text = new Text(\"myColFam\")\nval colQual: Text = new Text(\"myColQual\")\nval colVis: ColumnVisibility = new ColumnVisibility(\"private\")\nval timestamp: long = System.currentTimeMillis()\nval value: Value = new Value(field..getBytes())\nval mutation: Mutation = new Mutation(rowID)\n\nmutation.put(colFam, colQual, colVis, timestamp, value)\n```", "```scala\nval conn: Connector = inst.getConnector(\"user\", \"passwd\")\nval auths: Authorizations = new Authorizations(\"private\")\nval scan: Scanner = conn.createScanner(\"table\", auths)\n\nscan.setRange(new Range(\"harry\",\"john\"))\nscan.fetchFamily(\"attributes\")\n\nfor(Entry<Key,Value> entry : scan) {\n\u00a0\u00a0  val row: String = e.getKey().getRow()\n\u00a0\u00a0  val value: Value = e.getValue()\n}\n```", "```scala\nAndrew Jones, 17 New Road London XXXXXX, 0207XXXXXX, 4659XXXXXXXXXXXX\n```", "```scala\ndef getHybridResult(text: String): String = {\n\n \u00a0Array(\n \u00a0\u00a0 forenames(scala.util.Random.nextInt(forenames.length)),\n \u00a0\u00a0 RecordField.SURNAME,\n \u00a0\u00a0 streets(scala.util.Random.nextInt(streets.length)),\n \u00a0\u00a0 RecordField.ADDRESS2,\n \u00a0\u00a0 RecordField.POSTCODE,\n \u00a0\u00a0 RecordField.TELNUMBER,\n \u00a0\u00a0 RandomCCNumber,\n \u00a0\u00a0 \"Unknown field\")\n\u00a0 .zip(text.split(\",\"))\n \u00a0.map { case (m, field) =>\n \u00a0\u00a0 m match {\n \u00a0\u00a0\u00a0\u00a0 case m:String => m\n \u00a0\u00a0\u00a0\u00a0 case rf:RecordField.Obfuscation =>\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0  stringObfuscator(field,rf.toString,'X')\n \u00a0\u00a0\u00a0}\n \u00a0}\n \u00a0.mkString(\",\")\n}\n```", "```scala\nSimon,XXXXXX,51 St James,London,XX 2AA,XXXX 123456,0264 1755 2288 6600\n```", "```scala\nval data = dataset.map { case record =>\n\u00a0\u00a0\u00a0\u00a0 getMixedResult(record)\n}\ndata.saveAsTextFile(\"/output/data/path\", classOf[CryptoCodec])\n```", "```scala\n> kinit \nPassword for user: \n> spark-shell \nSpark session available as 'spark'. \nWelcome to \n      ____              __ \n     / __/__  ___ _____/ /__ \n    _\\ \\/ _ \\/ _ `/ __/  '_/ \n   /___/ .__/\\_,_/_/ /_/\\_\\   version 2.0.1 \n      /_/ \n\nUsing Scala version 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_101) \nType in expressions to have them evaluated. \nType :help for more information. \n\nscala> val file = sc.textFile(\"hdfs://...\") \nscala> file.count \n\n```", "```scala\nspark-submit \n \u00a0\u00a0--master\u00a0yarn-client\n \u00a0\u00a0--class SparkDriver\n \u00a0\u00a0--files\u00a0keytab.file\n \u00a0\u00a0--keytab\u00a0keytab.file\n \u00a0\u00a0--principal\u00a0username@domain\nApplicationName\n```", "```scala\n> JDBC_DRIVER_JAR=sqljdbc.jar \n> spark-shell  \n  --master yarn-client  \n  --driver-class-path $JDBC_DRIVER_JAR  \n  --files keytab.file   --conf spark.driver.extraClassPath=$JDBC_DRIVER_JAR \n  --conf spark.executor.extraClassPath=$JDBC_DRIVER_JAR \n  --jars $JDBC_DRIVER_JAR \n\n```", "```scala\nimport org.apache.spark.rdd.JdbcRDD \n\nnew JdbcRDD(sc, ()=>{ \n        import org.apache.hadoop.security.UserGroupInformation \n        import UserGroupInformation.AuthenticationMethod \n        import org.apache.hadoop.conf.Configuration \n        import org.apache.spark.SparkFiles \n        import java.sql.DriverManager \n        import java.security.PrivilegedAction \n        import java.sql.Connection \n\n        val driverClassName = \"com.microsoft.sqlserver.jdbc.SQLServerDriver\" \n        val url = \"jdbc:sqlserver://\" + \n                  \"host:port;instanceName=DB;\" + \n                  \"databaseName=mydb;\" +  \n                  \"integratedSecurity=true;\" +  \n                  \"authenticationScheme=JavaKerberos\" \n\n        Class.forName(driverClassName) \n        val conf = new Configuration \n        conf.addResource(\"/etc/hadoop/conf/core-site.xml\") \n        conf.addResource(\"/etc/hadoop/conf/mapred-site.xml\") \n        conf.addResource(\"/etc/hadoop/conf/hdfs-site.xml\") \n        UserGroupInformation.setConfiguration(conf) \n\n        UserGroupInformation \n           .getCurrentUser \n           .setAuthenticationMethod(AuthenticationMethod.KERBEROS) \n        UserGroupInformation \n           .loginUserFromKeytabAndReturnUGI(principal, keytab.file) \n           .doAs(new PrivilegedAction[Connection] { \n             override def run(): Connection =  \n                  DriverManager.getConnection(url) \n           }) \n\n},  \n\"SELECT * FROM books WHERE id <= ? and id >= ?\",  \n1,           // lowerBound    - the minimum value of the first placeholder \n20,          // upperBound    - the maximum value of the second placeholder \n4)           // numPartitions - the number of partitions \n\n```", "```scala\nSELECT * FROM books WHERE id <= 1 and id >= 5 \nSELECT * FROM books WHERE id <= 6 and id >= 10 \nSELECT * FROM books WHERE id <= 11 and id >= 15 \nSELECT * FROM books WHERE id <= 16 and id >= 20 \n\n```"]