["```scala\ndef readFile(song: String) = {\n\u00a0 val is = new FileInputStream(song)\n \u00a0 processSong(is)\n}\ndef processSong(stream: InputStream): Array[Byte] = {\n\n \u00a0 val bufferedIn = new BufferedInputStream(stream)\n \u00a0 val out = new ByteArrayOutputStream\n \u00a0 val audioInputStream = AudioSystem.getAudioInputStream(bufferedIn)\n\n \u00a0 val format = audioInputStream.getFormat\n \u00a0 val sizeTmp = Math.rint((format.getFrameRate *\n\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0format.getFrameSize) /\n\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0format.getFrameRate)\n\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.toInt\n\n\u00a0 val size = (sizeTmp + format.getFrameSize) -\n\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(sizeTmp % format.getFrameSize)\n\n \u00a0 val buffer = new Array[Byte](size)\n\n \u00a0 var available = true\n \u00a0 var totalRead = 0\n \u00a0 while (available) {\n \u00a0\u00a0 \u00a0val c = audioInputStream.read(buffer, 0, size)\n \u00a0\u00a0\u00a0 totalRead += c\n \u00a0\u00a0\u00a0 if (c > -1) {\n \u00a0\u00a0\u00a0\u00a0 \u00a0out.write(buffer, 0, c)\n \u00a0\u00a0\u00a0 } else {\n \u00a0\u00a0\u00a0\u00a0 \u00a0available = false\n \u00a0\u00a0\u00a0 }\n \u00a0\u00a0}\n\n \u00a0\u00a0audioInputStream.close()\n \u00a0\u00a0out.close()\n \u00a0\u00a0out.toByteArray\n }\n```", "```scala\nval format = audioInputStream.getFormat\n\nval sampleRate = format.getSampleRate\n\nval sizeTmp = Math.rint((format.getFrameRate *\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0format.getFrameSize) /\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0format.getFrameRate)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.toInt\n\n val size = (sizeTmp + format.getFrameSize) -\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(sizeTmp % format.getFrameSize)\n\n val byteFreq = format.getFrameSize * format.getFrameRate.toInt\n```", "```scala\nval data: Array[Byte] = processSong(inputStream)\n\nval timeDomain: Array[(Double, Int)] = data\n\u00a0\u00a0.zipWithIndex\n\u00a0\u00a0.map { case (b, idx) =>\n \u00a0\u00a0\u00a0\u00a0\u00a0(minTime + idx * 1000L / byteFreq.toDouble, b.toInt)\n \u00a0\u00a0}\n```", "```scala\ncase class Audio(data: Array[Byte],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0byteFreq: Int,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sampleRate: Float,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0minTime: Long,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0id: Int= 0) {\n\n \u00a0def duration: Double =\n\u00a0\u00a0\u00a0\u00a0(data.length + 1) * 1000L / byteFreq.toDouble\n\n \u00a0def timeDomain: Array[(Double, Int)] = data\n\u00a0\u00a0\u00a0.zipWithIndex\n\u00a0\u00a0\u00a0.map { case (b, idx) =>\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(minTime + idx * 1000L / byteFreq.toDouble, b.toInt)\n \u00a0\u00a0\u00a0}\n\n \u00a0def findPeak: Float = {\n \u00a0\u00a0\u00a0val freqDomain = frequencyDomain()\n \u00a0\u00a0\u00a0freqDomain\n\u00a0\u00a0\u00a0\u00a0\u00a0.sortBy(_._2)\n\u00a0\u00a0\u00a0\u00a0\u00a0.reverse\n\u00a0\u00a0\u00a0\u00a0\u00a0.map(_._1)\n\u00a0\u00a0\u00a0\u00a0\u00a0.head\n \u00a0}\n\n // Next to come\n\n }\n```", "```scala\ndef read(library: String, sc: SparkContext) = {\n\u00a0\u00a0\u00a0sc.binaryFiles(library)\n\u00a0\u00a0\u00a0\u00a0 .filter { case (filename, stream) =>\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 filename.endsWith(\".wav\")\n\u00a0\u00a0\u00a0\u00a0 }\n\u00a0\u00a0\u00a0\u00a0 .map { case (filename, stream) =>\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0val audio = \u00a0processSong(stream.open())\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 (filename, audio)\n\u00a0\u00a0\u00a0\u00a0 }\n}\n\nval audioRDD: RDD[(String, Audio)] = read(library, sc)\n```", "```scala\ndef fft(): Array[Complex] = {\n\n \u00a0val array = Audio.paddingToPowerOf2(data)\n \u00a0val transformer = new FastFourierTransformer(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DftNormalization.STANDARD)\n\n \u00a0transformer.transform(array.map(_.toDouble),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0TransformType.FORWARD)\n\n}\n```", "```scala\ndef frequencyDomain(): Array[(Float, Double)] = {\n\n \u00a0 val t = fft()\n \u00a0 t.take(t.length / 2) // Nyquist\n\u00a0\u00a0 .zipWithIndex\n\u00a0\u00a0 .map { case (c, idx) =>\n \u00a0\u00a0 \u00a0\u00a0val freq = (idx + 1) * sampleRate / t.length\n \u00a0\u00a0\u00a0 \u00a0val amplitude = \u00a0sqrt(pow(c.getReal, 2) +\n\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0pow(c.getImaginary, 2))\n \u00a0\u00a0\u00a0\u00a0 val db = 20 * log10(amplitude)\n \u00a0\u00a0\u00a0 \u00a0(freq, db)\n \u00a0 \u00a0}\n\n }\n```", "```scala\ndef sampleByTime(duration: Double = 20.0d,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0padding: Boolean = true): List[Audio] = {\n\n \u00a0 val \u00a0size = (duration * byteFreq / 1000.0f).toInt\n \u00a0 sample(size, padding)\n\n }\n\n def sample(size: Int= math.pow(2, 20).toInt,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0padding: Boolean = true): List[Audio] = {\n\n \u00a0 Audio\n\u00a0 \u00a0\u00a0.sample(data, size, padding)\n\u00a0\u00a0\u00a0 .zipWithIndex\n\u00a0\u00a0\u00a0 .map { case (sampleAudio, idx) =>\n\u00a0\u00a0\u00a0\u00a0 \u00a0val firstByte = idx * size\n \u00a0\u00a0\u00a0\u00a0 \u00a0val firstTime = firstByte * 1000L / byteFreq.toLong\n \u00a0\u00a0\u00a0\u00a0 \u00a0Audio(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 sampleAudio,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 byteFreq,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 sampleRate,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 firstTime,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 idx\n\u00a0\u00a0\u00a0\u00a0 \u00a0)\n \u00a0 \u00a0}\n\n }\n\nval sampleRDD = audioRDDflatMap { case (song, audio) =>\n \u00a0 audio.sampleByTime()\n\u00a0\u00a0\u00a0 .map { sample =>\n \u00a0\u00a0\u00a0\u00a0\u00a0 (song, sample)\n \u00a0\u00a0\u00a0 }\n }\n```", "```scala\ndef hash: String = {\n \u00a0val freqDomain = frequencyDomain()\n \u00a0freqDomain.groupBy { case (fq, db) =>\n \u00a0\u00a0\u00a0Audio.getFrequencyBand(fq)\n \u00a0}.map { case (bucket, frequencies) =>\n \u00a0\u00a0\u00a0val (dominant, _) = frequencies.map { case (fq, db) =>\n \u00a0\u00a0\u00a0\u00a0\u00a0(Audio.findClosestNote(fq), db)\n \u00a0\u00a0\u00a0}.sortBy { case (note, db) =>\n \u00a0\u00a0\u00a0\u00a0\u00a0db\n \u00a0\u00a0\u00a0}.last\n \u00a0\u00a0\u00a0(bucket, dominant)\n \u00a0}.toList\n\u00a0.sortBy(_._1)\n\u00a0.map(_._2)\n\u00a0.mkString(\"-\")\n }\n\n*/** \n*001 Amadeus Mozart - Requiem (K. 626)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 E-D#-A-B-B-F* \n*001 Amadeus Mozart - Requiem (K. 626)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 G#-D-F#-B-B-F* \n*001 Amadeus Mozart - Requiem (K. 626)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 F#-F#-C-B-C-F* \n*001 Amadeus Mozart - Requiem (K. 626)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 E-F-F#-B-B-F* \n*001 Amadeus Mozart - Requiem (K. 626)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 E-F#-C#-B-B-F* \n*001 Amadeus Mozart - Requiem (K. 626)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 B-E-F-A#-C#-F* \n**/*\n\n```", "```scala\ncase class HashSongsPair(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 id: String,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 songs: List[Long]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 )\n\n val hashRDD = sampleRDD.map { case (id, sample) =>\n \u00a0 (sample.hash, id)\n \u00a0}\n\u00a0.groupByKey()\n\u00a0.map { case (id, songs) =>\n \u00a0 \u00a0HashSongsPair(id, songs.toList)\n \u00a0}\n```", "```scala\n<dependency>\n  <groupId>com.datastax.spark</groupId>\n  <artifactId>spark-cassandra-connector_2.11</artifactId>            \n  <version>2.0.0</version>\n</dependency> \n\n```", "```scala\nimport com.datastax.spark.connector._\n\n val keyspace = \"gzet\"\n val table = \"hashes\"\n\n // Persist RDD\n hashRDD.saveAsCassandraTable(keyspace, table)\n\n // Retrieve RDD\n val retrievedRDD = sc.cassandraTable[HashSongsPair](\n\u00a0 keyspace,\n\u00a0 table\n)\n```", "```scala\nCREATE TABLE gzet.hashes (\n\u00a0 id text PRIMARY KEY,\n\u00a0 songs list<bigint>\n)\n```", "```scala\nval cluster = Cluster\n\u00a0 .builder()\n\u00a0 .addContactPoint(cassandraHost)\n\u00a0 .withPort(cassandraPort)\n\u00a0 .build()\nval session = cluster.connect()\n\n def findSongsByHash(hash: String): List[Long] = {\n \u00a0 val stmt = s\"SELECT songs FROM hashes WHERE id = '$hash';\"\n \u00a0 val results = session.execute(stmt)\n \u00a0 results flatMap { row =>\n \u00a0\u00a0\u00a0 row.getList(\"songs\", classOf[Long])\n \u00a0 }\n\u00a0  .toList\n }\n```", "```scala\n<div>\n \u00a0 <input type=\"text\" class=\"form-control\">\n \u00a0 <span class=\"input-group-btn\">\n \u00a0 \u00a0\u00a0<button class=\"btn-primary\">Upload</button>\n\u00a0 \u00a0\u00a0 <button class=\"btn-success\">Analyze</button>\n \u00a0 </span>\n</div>\n```", "```scala\ndef index = Action { implicit request =>\n \u00a0 Ok(views.html.analyze(\"Select a wav file to analyze\"))\n }\n\n def submit = Action(parse.multipartFormData) { request =>\n \u00a0 request.body.file(\"song\").map { upload =>\n \u00a0\u00a0\u00a0 val file = new File(s\"/tmp/${UUID.randomUUID()}\")\n \u00a0\u00a0\u00a0 upload.ref.moveTo(file)\n \u00a0\u00a0\u00a0 val song = process(file)\n \u00a0\u00a0\u00a0 if(song.isEmpty) {\n \u00a0\u00a0\u00a0\u00a0\u00a0 Redirect(routes.Analyze.index())\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0  .flashing(\"warning\" -> s\"No match\")\n \u00a0\u00a0\u00a0 } else {\n \u00a0\u00a0\u00a0\u00a0\u00a0 Redirect(routes.Analyze.index())\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0  .flashing(\"success\" -> song.get)\n \u00a0\u00a0\u00a0 }\n \u00a0 }.getOrElse {\n \u00a0\u00a0\u00a0 Redirect(routes.Analyze.index())\n  \u00a0\u00a0\u00a0\u00a0\u00a0.flashing(\"error\" -> \"Missing file\")\n \u00a0 }\n }\n\n def process(file: File): Option[String] = {\n \u00a0 val is = new FileInputStream(file)\n \u00a0 val audio = Audio.processSong(is)\n \u00a0 val potentialMatches = audio.sampleByTime().map {a =>\n\u00a0\u00a0\u00a0  queryCassandra(a.hash)\n\u00a0  }\n \u00a0 bestMatch(potentialMatches)\n }\n```", "```scala\nGET \u00a0\u00a0\u00a0\u00a0 /analyze \u00a0\u00a0\u00a0\u00a0\u00a0controllers.Analyze.index\nPOST \u00a0\u00a0\u00a0 /analyze \u00a0\u00a0\u00a0\u00a0\u00a0controllers.Analyze.submit\n```", "```scala\nval hashSongsRDD = sc.cassandraTable[HashSongsPair](\"gzet\", \"hashes\")\n\n val songHashRDD = hashSongsRDD flatMap { hash =>\n \u00a0\u00a0\u00a0\u00a0hash.songs map { song =>\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0((hash, song), 1)\n \u00a0\u00a0\u00a0\u00a0}\n \u00a0\u00a0}\n\n val songTfRDD = songHashRDD map { case ((hash,songId),count) =>\n \u00a0\u00a0\u00a0\u00a0(songId, count)\n \u00a0\u00a0} reduceByKey(_+_)\n\n val songTf = sc.broadcast(songTfRDD.collectAsMap())\n```", "```scala\nimplicit class Crossable[X](xs: Traversable[X]) {\n \u00a0\u00a0\u00a0\u00a0\u00a0def cross[Y](ys: Traversable[Y]) = for { x <- xs; y <- ys } yield (x, y)\n\nval crossSongRDD = songHashRDD.keys\n\u00a0\u00a0\u00a0\u00a0.groupByKey()\n\u00a0\u00a0\u00a0\u00a0.values\n\u00a0\u00a0\u00a0\u00a0.flatMap { songIds =>\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0songIds cross songIds filter { case (from, to) =>\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0from != to\n \u00a0\u00a0\u00a0\u00a0\u00a0}.map(_ -> 1)\n \u00a0\u00a0\u00a0}.reduceByKey(_+_)\n\u00a0\u00a0\u00a0\u00a0 .map { case ((from, to), count) =>\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0val weight = count.toDouble /\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 songTfB.value.getOrElse(from, 1)\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Edge(from, to, weight)\n \u00a0\u00a0\u00a0}.filter { edge =>\n \u00a0\u00a0\u00a0\u00a0edge.attr > minSimilarityB.value\n \u00a0\u00a0}\n\nval graph = Graph.fromEdges(crossSongRDD, 0L)\n```", "```scala\nval prGraph = graph.pageRank(0.001, 0.15)\n```", "```scala\ncase class Song(id: Long, name: String, commonality: Double)\nval vertices = prGraph\n\u00a0 .vertices\n\u00a0\u00a0.mapPartitions { vertices =>\n \u00a0\u00a0\u00a0val songIds = songIdsB\n\u00a0\u00a0.value\n\u00a0\u00a0.vertices\n\u00a0\u00a0.map { case (songId, pr) =>\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0val songName = songIds.get(vId).get\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Song(songId, songName, pr)\n \u00a0\u00a0\u00a0\u00a0\u00a0}\n \u00a0}\n\n vertices.saveAsCassandraTable(\"gzet\", \"playlist\")\n```", "```scala\nval graph = Graph.fromEdges(edgeRDD, 0L)\nval prGraph = graph.personalizedPageRank(id, 0.001, 0.1)\n```", "```scala\nGET\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0/playlist\u00a0\u00a0\u00a0\u00a0\u00a0 controllers.Playlist.index\n```", "```scala\ndef getSongs: List[Song] = {\n \u00a0 val s = \"SELECT id, name, commonality FROM gzet.playlist;\"\n \u00a0 val results = session.execute(s)\n \u00a0 results map { row =>\n \u00a0\u00a0\u00a0 val id = row.getLong(\"id\")\n \u00a0\u00a0\u00a0 val name = row.getString(\"name\")\n \u00a0\u00a0\u00a0 val popularity = row.getDouble(\"commonality\")\n \u00a0\u00a0\u00a0 Song(id, name, popularity)\n \u00a0 } toList\n }\n\n def index = Action { implicit request =>\n \u00a0 val playlist = models.Playlist(getSongs)\n \u00a0 Ok(views.html.playlist(playlist))\n }\n```", "```scala\n@(playlist: Playlist)\n\n@displaySongs(playlist: Playlist) = {\n \u00a0 @for(node <- playlist.songs.sortBy(_.commonality).reverse) {\n \u00a0\u00a0\u00a0 <a href=\"/playlist/@node.id\" class=\"list-group-item\">\n \u00a0\u00a0\u00a0\u00a0\u00a0 <iclass=\"glyphiconglyphicon-play\"></i>\n \u00a0\u00a0\u00a0\u00a0\u00a0 <span class=\"badge\">\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 @node.commonality\n \u00a0\u00a0\u00a0\u00a0\u00a0 </span>\n \u00a0\u00a0\u00a0\u00a0\u00a0 @node.name\n \u00a0\u00a0\u00a0 </a>\n \u00a0 }\n }\n\n @main(\"playlist\") {\n \u00a0 <div class=\"row\">\n \u00a0 \u00a0\u00a0<div class=\"list-group\">\n \u00a0\u00a0\u00a0 \u00a0\u00a0@displaySongs(playlist)\n \u00a0 \u00a0\u00a0</div>\n \u00a0 </div>\n }\n```", "```scala\ncurl -XPOST 'localhost:8090/contexts/gzet?\\\n\u00a0 num-cpu-cores=4&\\\n\u00a0 memory-per-node=4g&\\\n\u00a0 spark.executor.instances=2&\\\n\u00a0 spark.driver.memory=2g&\\\n\u00a0 passthrough.spark.cassandra.connection.host=127.0.0.1&\\\n\u00a0 passthrough.spark.cassandra.connection.port=9042'\n```", "```scala\n<dependency>\n \u00a0 <groupId>spark.jobserver</groupId>\n \u00a0 <artifactId>job-server-api_2.11</artifactId>\n \u00a0 <version>spark-2.0-preview</version>\n </dependency>\n```", "```scala\nobject PlaylistBuilder extends SparkJob {\n\n \u00a0override def runJob(\n\u00a0\u00a0  sc: SparkContext,\n\u00a0\u00a0  jobConfig: Config\n\u00a0 ): Any = ???\n\n  override def validate(\n\u00a0\u00a0  sc: SparkContext,\n\u00a0\u00a0  config: Config\n\u00a0 ): SparkJobValidation = ???\n\n}\n```", "```scala\nthis.namedRdds.update(\"rdd:edges\", edgeRDD)\nthis.namedRdds.update(\"rdd:nodes\", nodeRDD)\n```", "```scala\nval edgeRDD = this.namedRdds.get[Edge](\"rdd:edges\").get\nval nodeRDD = this.namedRdds.get[Node](\"rdd:nodes\").get\n\nval graph = Graph.fromEdges(edgeRDD, 0L)\n```", "```scala\nval prGraph = graph.personalizedPageRank(id, 0.001, 0.1)\n\nprGraph\n\u00a0.vertices\n\u00a0.map { case(vId, pr) =>\n \u00a0\u00a0List(vId, songIds.value.get(vId).get, pr).mkString(\",\")\n \u00a0}\n\u00a0.take(50)\n```", "```scala\ncurl --data-binary @recommender-core-1.0.jar \\\n\u00a0'localhost:8090/jars/gzet'\n```", "```scala\n# Asynchronous Playlist Builder\ncurl -XPOST 'localhost:8090/jobs?\\\n context=gzet&\\\n appName=gzet&\\\n classPath=io.gzet.recommender.PlaylistBuilder'\n\n# Synchronous Personalized Playlist for song 12\ncurl -XPOST -d \"song.id=12\" 'localhost:8090/jobs?\\\n context=gzet&\\\n appName=gzet&\\\n sync=true&\\\n timeout=60000&\\\n classPath=io.gzet.recommender.PersonalizedPlaylistBuilder'\n```", "```scala\nGET /playlist/:id controllers.Playlist.personalize(id: Long) \n\n```", "```scala\ndef personalize(id: Long) = Action { implicit request =>\n \u00a0 val name = cassandra.getSongName(id)\n \u00a0 try {\n \u00a0\u00a0 \u00a0val nodes = sparkServer.generatePlaylist(id)\n \u00a0\u00a0 \u00a0val playlist = models.Playlist(nodes, name)\n \u00a0\u00a0 \u00a0Ok(views.html.playlist(playlist))\n \u00a0\u00a0} catch {\n \u00a0 \u00a0\u00a0case e: Exception =>\n \u00a0\u00a0 \u00a0\u00a0\u00a0Redirect(routes.Playlist.index())\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 .flashing(\"error\" -> e.getMessage)\n \u00a0\u00a0}\n }\n```"]