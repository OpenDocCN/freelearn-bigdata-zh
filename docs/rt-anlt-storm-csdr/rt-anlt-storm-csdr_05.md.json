["```scala\n<ip address1>     <hostname1> <shortname1> \n<ip address2>     <hostname2> <shortname2> \n```", "```scala\n10.191.206.83     rmq-flc-1.mydomain.net rmq-flc-1 \n10.73.10.63       rmq-flc-2.mydomain.net rmq-flc-2\n```", "```scala\n#!/bin/sh\nsudo cat <<EOF > /etc/apt/sources.list.d/rabbitmq.list\nsudo deb http://www.rabbitmq.com/debian/ testing main\nEOF\n\nsudo curl http://www.rabbitmq.com/rabbitmq-signing-key-public.asc -o  /tmp/rabbitmq-signing-key-public.asc\nsudo apt-key add /tmp/rabbitmq-signing-key-public.asc\nsudo rm /tmp/rabbitmq-signing-key-public.asc\n\nsudo apt-get -qy update\nsudo apt-get -qy install rabbitmq-server\n\n```", "```scala\n    sudo service rabbitmq-server start\n\n    ```", "```scala\n    sudo service rabbitmq-server status\n\n    ```", "```scala\n    sudo rabbitmq-plugins enable rabbitmq_management\n\n    ```", "```scala\n    sudo rabbitmq-plugins enable rabbitmq_management\n\n    ```", "```scala\n    sudo service rabbitmq-server start\n\n    ```", "```scala\n    sudo rabbitmqctl stop_app\n    sudo rabbitmqctl join_cluster rabbit@rmq-flc-1\n    sudo rabbitmqctl start_app\n\n    ```", "```scala\n    sudo service rabbitmq-server status\n\n    ```", "```scala\n    sudo /usr/lib/rabbitmq/bin/rabbitmq-plugins enable  rabbitmq_management\n\n    ```", "```scala\n    The following plugins have been enabled:\n    mochiweb\n    webmachine\n    rabbitmq_mochiweb\n    amqp_client\n    rabbitmq_management_agent\n    rabbitmq_management\n    Plugin configuration has changed. Restart RabbitMQ for changes to take effect.\n\n    ```", "```scala\n    sudo service rabbitmq-server restart \n\n    ```", "```scala\npublic class AMQPRecvSpout implements IRichSpout{\n\n//The constructor where we set initialize all properties\n  public AMQPRecvSpout(String host, int port, String username,  String password, String vhost, boolean requeueOnFail, boolean  autoAck) {\n    this.amqpHost = host;\n    this.amqpPort = port;\n    this.amqpUsername = username;\n    this.amqpPasswd = password;\n    this.amqpVhost = vhost;\n    this.requeueOnFail = requeueOnFail;\n    this.autoAck = autoAck;\n  }\n/*\nOpen method of the spout , here we initialize the prefetch count ,  this parameter specified how many messages would be prefetched  from the queue by the spout \u2013 to increase the efficiency of the  solution */\n  public void open(@SuppressWarnings(\"rawtypes\") Map conf,  TopologyContext context, SpoutOutputCollector collector) {\n    Long prefetchCount = (Long) conf.get(CONFIG_PREFETCH_COUNT);\n    if (prefetchCount == null) {\n      log.info(\"Using default prefetch-count\");\n      prefetchCount = DEFAULT_PREFETCH_COUNT;\n    } else if (prefetchCount < 1) {\n      throw new IllegalArgumentException(CONFIG_PREFETCH_COUNT + \"  must be at least 1\");\n    }\n    this.prefetchCount = prefetchCount.intValue();\n\n    try {\n      this.collector = collector;\n      setupAMQP();\n    } catch (IOException e) {\n      log.error(\"AMQP setup failed\", e);\n      log.warn(\"AMQP setup failed, will attempt to reconnect...\");\n      Utils.sleep(WAIT_AFTER_SHUTDOWN_SIGNAL);\n      reconnect();\n    }\n  }\n\n  /**\n   * Reconnect to an AMQP broker.in case the connection breaks at  some point\n   */\n  private void reconnect() {\n    log.info(\"Reconnecting to AMQP broker...\");\n    try {\n      setupAMQP();\n    } catch (IOException e) {\n      log.warn(\"Failed to reconnect to AMQP broker\", e);\n    }\n  }\n  /**\n   * Set up a connection with an AMQP broker.\n   * @throws IOException\n   *This is the method where we actually connect to the queue  using AMQP client APIs\n   */\n  private void setupAMQP() throws IOException{\n    final int prefetchCount = this.prefetchCount;\n    final ConnectionFactory connectionFactory = new  ConnectionFactory() {\n      public void configureSocket(Socket socket)\n          throws IOException {\n        socket.setTcpNoDelay(false);\n        socket.setReceiveBufferSize(20*1024);\n        socket.setSendBufferSize(20*1024);\n      }\n    };\n\n    connectionFactory.setHost(amqpHost);\n    connectionFactory.setPort(amqpPort);\n    connectionFactory.setUsername(amqpUsername);\n    connectionFactory.setPassword(amqpPasswd);\n    connectionFactory.setVirtualHost(amqpVhost);\n\n    this.amqpConnection = connectionFactory.newConnection();\n    this.amqpChannel = amqpConnection.createChannel();\n    log.info(\"Setting basic.qos prefetch-count to \" +  prefetchCount);\n    amqpChannel.basicQos(prefetchCount);\n    amqpChannel.exchangeDeclare(Constants.EXCHANGE_NAME,  \"direct\");\n    amqpChannel.queueDeclare(Constants.QUEUE_NAME, true, false,  false, null);\n    amqpChannel.queueBind(Constants.QUEUE_NAME,  Constants.EXCHANGE_NAME, \"\");\n    this.amqpConsumer = new QueueingConsumer(amqpChannel);\n    assert this.amqpConsumer != null;\n    this.amqpConsumerTag =  amqpChannel.basicConsume(Constants.QUEUE_NAME, this.autoAck,  amqpConsumer);\n  }\n\n  /* \n   * Cancels the queue subscription, and disconnects from the AMQP  broker.\n   */\n  public void close() {\n    try {\n      if (amqpChannel != null) {\n        if (amqpConsumerTag != null) {\n          amqpChannel.basicCancel(amqpConsumerTag);\n        }\n        amqpChannel.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Error closing AMQP channel\", e);\n    }\n\n    try {\n      if (amqpConnection != null) {\n        amqpConnection.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Error closing AMQP connection\", e);\n    }\n  }\n  /* \n   * Emit message received from queue into collector\n   */\n  public void nextTuple() {\n    if (spoutActive && amqpConsumer != null) {\n      try {\n        final QueueingConsumer.Delivery delivery =  amqpConsumer.nextDelivery(WAIT_FOR_NEXT_MESSAGE);\n        if (delivery == null) return;\n        final long deliveryTag =  delivery.getEnvelope().getDeliveryTag();\n        String message = new String(delivery.getBody());\n\n        if (message != null && message.length() > 0) {\n          collector.emit(new Values(message), deliveryTag);\n        } else {\n          log.debug(\"Malformed deserialized message, null or zero- length. \" + deliveryTag);\n          if (!this.autoAck) {\n            ack(deliveryTag);\n          }\n        }\n      } catch (ShutdownSignalException e) {\n        log.warn(\"AMQP connection dropped, will attempt to  reconnect...\");\n        Utils.sleep(WAIT_AFTER_SHUTDOWN_SIGNAL);\n        reconnect();\n      } catch (ConsumerCancelledException e) {\n        log.warn(\"AMQP consumer cancelled, will attempt to  reconnect...\");\n        Utils.sleep(WAIT_AFTER_SHUTDOWN_SIGNAL);\n        reconnect();\n      } catch (InterruptedException e) {\n        log.error(\"Interrupted while reading a message, with  Exception : \" +e);\n      }\n    }\n  }\n  /* \n   * ack method to acknowledge the message that is successfully  processed \n*/\n\n  public void ack(Object msgId) {\n    if (msgId instanceof Long) {\n      final long deliveryTag = (Long) msgId;\n      if (amqpChannel != null) {\n        try {\n          amqpChannel.basicAck(deliveryTag, false);\n        } catch (IOException e) {\n          log.warn(\"Failed to ack delivery-tag \" + deliveryTag,  e);\n        } catch (ShutdownSignalException e) {\n          log.warn(\"AMQP connection failed. Failed to ack  delivery-tag \" + deliveryTag, e);\n        }\n      }\n    } else {\n      log.warn(String.format(\"don't know how to ack(%s: %s)\",  msgId.getClass().getName(), msgId));\n    }\n  }\n\n  public void fail(Object msgId) {\n    if (msgId instanceof Long) {\n      final long deliveryTag = (Long) msgId;\n      if (amqpChannel != null) {\n        try {\n          if (amqpChannel.isOpen()) {\n            if (!this.autoAck) {\n              amqpChannel.basicReject(deliveryTag, requeueOnFail);\n            }\n          } else {\n            reconnect();\n          }\n        } catch (IOException e) {\n          log.warn(\"Failed to reject delivery-tag \" + deliveryTag,  e);\n        }\n      }\n    } else {\n      log.warn(String.format(\"don't know how to reject(%s: %s)\",  msgId.getClass().getName(), msgId));\n    }\n  }\n\npublic void declareOutputFields(OutputFieldsDeclarer declarer) {\n    declarer.declare(new Fields(\"messages\"));\n  }\n}\n```", "```scala\n    <dependency>\n      <groupId>com.rabbitmq</groupId>\n      <artifactId>amqp-client</artifactId>\n      <version>3.2.1</version>\n    </dependency>\n```", "```scala\npublic class FixedEmitter {\n  private static final String EXCHANGE_NAME = \"MYExchange\";\n  public static void main(String[] argv) throws Exception {\n    /*we are creating a new connection factory for builing  connections with exchange*/\n    ConnectionFactory factory = new ConnectionFactory();\n    /* we are specifying the RabbitMQ host address and port here  in */\n\n    Address[] addressArr = {\n      new Address(\"localhost\", 5672)\n    }; //specify the IP if the queue is not on local node where  this program would execute \n    Connection connection = factory.newConnection(addressArr);\n    //creating a channel for rabbitMQ\n    Channel channel = connection.createChannel();\n    //Declaring the queue and routing key\n    String queueName = \"MYQueue\";\n    String routingKey = \"MYQueue\";\n    //Declaring the Exchange\n    channel.exchangeDeclare(EXCHANGE_NAME, \"direct\", false);\n    Map < String, Object > args = new HashMap < String, Object >  ();\n    //defining the queue policy\n    args.put(\"x-ha-policy\", \"all\");\n    //declaring and binding the queue to the exchange\n    channel.queueDeclare(queueName, true, false, false, args);\n    channel.queueBind(queueName, EXCHANGE_NAME, routingKey);\n    String stoppedRecord;\n    int i = 0;\n    //emitting sample records\n    while (i < 1) {\n      try {\n        myRecord = \"MY Sample record\";\n        channel.basicPublish(EXCHANGE_NAME, routingKey,\n          MessageProperties.PERSISTENT_TEXT_PLAIN,\n          myRecord.getBytes());\n        System.out.println(\" [x] Sent '\" + myRecord + \"' sent at \"  + new Date());\n        i++;\n        Thread.sleep(2);\n      } catch (Exception e) {\n        e.printStackTrace();\n      }\n    }\n    channel.close();\n    connection.close();\n  }\n}\n```", "```scala\nbuilder.setSpout(\"spout\", new RandomSentenceSpout(), 5);\nbuilder.setBolt(\"split\", new SplitSentence(),  8).shuffleGrouping(\"spout\");\nWe will use the new spout instead, as follows:\n\nbuilder.setSpout(\"queue_reader\", new  AMQPRecvSpout(Constants.RMQ_ADDRESS, 5672, \"guest\", \"guest\",  \"/\"));\n```", "```scala\nisolation.scheduler.machines: \n    \"Topol\": 2\n```"]