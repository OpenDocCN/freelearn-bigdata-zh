["```py\nimport pandas as pd \n\nr_cols = ['user_id', 'movie_id', 'rating'] \nratings = pd.read_csv('C:\\DataScience\\ml-100k\\u.data', sep='\\t', names=r_cols, usecols=range(3)) \nratings.head()ratings.head() \n\n```", "```py\nmovieProperties = ratings.groupby('movie_id').agg({'rating': \n [np.size, np.mean]}) \nmovieProperties.head() \n\n```", "```py\nmovieNumRatings = pd.DataFrame(movieProperties['rating']['size']) \nmovieNormalizedNumRatings = movieNumRatings.apply(lambda x: (x - np.min(x)) / (np.max(x) - np.min(x))) \nmovieNormalizedNumRatings.head() \n\n```", "```py\nmovieDict = {} \nwith open(r'c:/DataScience/ml-100k/u.item') as f: \n    temp = '' \n    for line in f: \n        fields = line.rstrip('\\n').split('|') \n        movieID = int(fields[0]) \n        name = fields[1] \n        genres = fields[5:25] \n        genres = map(int, genres) \n        movieDict[movieID] = (name, genres,      \n        movieNormalizedNumRatings.loc[movieID].get('size'),movieProperties.loc[movieID].rating.get('mean')) \n\n```", "```py\nmovieDict[1] \n\n```", "```py\nfrom scipy import spatial \n\ndef ComputeDistance(a, b): \n    genresA = a[1] \n    genresB = b[1] \n    genreDistance = spatial.distance.cosine(genresA, genresB) \n    popularityA = a[2] \n    popularityB = b[2] \n    popularityDistance = abs(popularityA - popularityB) \n    return genreDistance + popularityDistance \n\nComputeDistance(movieDict[2], movieDict[4]) \n\n```", "```py\nprint movieDict[2] \nprint movieDict[4] \n\n```", "```py\nimport operator \n\ndef getNeighbors(movieID, K): \n    distances = [] \n    for movie in movieDict: \n        if (movie != movieID): \n            dist = ComputeDistance(movieDict[movieID], \n movieDict[movie]) \n            distances.append((movie, dist)) \n    distances.sort(key=operator.itemgetter(1)) \n    neighbors = [] \n    for x in range(K): \n        neighbors.append(distances[x][0]) \n    return neighbors \n\nK = 10 \navgRating = 0 \nneighbors = getNeighbors(1, K) \nfor neighbor in neighbors: \n    avgRating += movieDict[neighbor][3] \n    print movieDict[neighbor][0] + \" \" + \n str(movieDict[neighbor][3]) \n    avgRating /= float(K) \n\n```", "```py\navgRating \n\n```", "```py\nfrom sklearn.datasets import load_iris \nfrom sklearn.decomposition import PCA \nimport pylab as pl \nfrom itertools import cycle \n\niris = load_iris() \n\nnumSamples, numFeatures = iris.data.shape \nprint numSamples \nprint numFeatures \nprint list(iris.target_names) \n\n```", "```py\nX = iris.data \npca = PCA(n_components=2, whiten=True).fit(X) \nX_pca = pca.transform(X) \n\n```", "```py\nprint pca.components_ \n\n```", "```py\nprint pca.explained_variance_ratio_ \nprint sum(pca.explained_variance_ratio_) \n\n```", "```py\ncolors = cycle('rgb') \ntarget_ids = range(len(iris.target_names)) \npl.figure() \nfor i, c, label in zip(target_ids, colors, iris.target_names): \n    pl.scatter(X_pca[iris.target == i, 0], X_pca[iris.target == i, 1], \n        c=c, label=label) \npl.legend() \npl.show() \n\n```"]