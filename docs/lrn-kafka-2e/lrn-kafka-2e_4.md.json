["```java\n    class KeyedMessage[K, V](val topic: String, val key: K, val message: V) \n    ```", "```java\nimport kafka.javaapi.producer.Producer;\nimport kafka.producer.KeyedMessage;\nimport kafka.producer.ProducerConfig;\n```", "```java\nProperties props = new Properties();\nprops.put(\"metadata.broker.list\",\"localhost:9092, localhost:9093, localhost:9094\");\nprops.put(\"serializer.class\",\"kafka.serializer.StringEncoder\");\nprops.put(\"request.required.acks\", \"1\");\nProducerConfig config = new ProducerConfig(props); \nProducer<String, String> producer = new Producer<String, String> (config);\n```", "```java\nString runtime = new Date().toString();;\nString msg = \"Message Publishing Time - \" + runtime;\nKeyedMessage<String, String> data = new KeyedMessage<String, String> (topic, msg);\nproducer.send(data); \n```", "```java\npackage kafka.examples.ch4;\n\nimport java.util.Date;\nimport java.util.Properties;\n\nimport kafka.javaapi.producer.Producer;\nimport kafka.producer.KeyedMessage;\nimport kafka.producer.ProducerConfig;\n\npublic class SimpleProducer {\n  private static Producer<String, String> producer;\n\n  public SimpleProducer() {\n    Properties props = new Properties();\n\n    // Set the broker list for requesting metadata to find the lead broker\n    props.put(\"metadata.broker.list\",\n            \"192.168.146.132:9092, 192.168.146.132:9093, 192.168.146.132:9094\");\n\n    //This specifies the serializer class for keys \n    props.put(\"serializer.class\", \"kafka.serializer.StringEncoder\");\n\n    // 1 means the producer receives an acknowledgment once the lead replica \n    // has received the data. This option provides better durability as the \n    // client waits until the server acknowledges the request as successful.\n    props.put(\"request.required.acks\", \"1\");\n\n    ProducerConfig config = new ProducerConfig(props);\n    producer = new Producer<String, String>(config);\n  }\n\n  public static void main(String[] args) {\n    int argsCount = args.length;\n    if (argsCount == 0 || argsCount == 1)\n      throw new IllegalArgumentException(\n        \"Please provide topic name and Message count as arguments\");\n\n    // Topic name and the message count to be published is passed from the\n    // command line \n    String topic = (String) args[0];\n    String count = (String) args[1];\n    int messageCount = Integer.parseInt(count);\n    System.out.println(\"Topic Name - \" + topic);\n    System.out.println(\"Message Count - \" + messageCount);\n\n    SimpleProducer simpleProducer = new SimpleProducer();\n    simpleProducer.publishMessage(topic, messageCount);\n  }\n\n  private void publishMessage(String topic, int messageCount) {\n    for (int mCount = 0; mCount < messageCount; mCount++) {\n      String runtime = new Date().toString();\n\n      String msg = \"Message Publishing Time - \" + runtime;\n      System.out.println(msg);\n      // Creates a KeyedMessage instance\n      KeyedMessage<String, String> data = \n        new KeyedMessage<String, String>(topic, msg);\n\n      // Publish the message\n      producer.send(data);\n    }\n    // Close producer connection with broker.\n    producer.close();\n  }\n}\n```", "```java\n[root@localhost kafka_2.9.2-0.8.1.1]#bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 3 --topic kafkatopic\n\n```", "```java\n[root@localhost kafka_2.9.2-0.8.1.1]# export KAFKA_LIB=/opt/kafka_2.9.2-0.8.1.1/libs\n[root@localhost kafka_2.9.2-0.8.1.1]# export CLASSPATH=.:$KAFKA_LIB/jopt-simple-3.2.jar:$KAFKA_LIB/kafka_2.9.2-0.8.1.1.jar:$KAFKA_LIB/log4j-1.2.15.jar:$KAFKA_LIB/metrics-core-2.2.0.jar:$KAFKA_LIB/scala-library-2.9.2.jar:$KAFKA_LIB/slf4j-api-1.7.2.jar:$KAFKA_LIB/slf4j-log4j12-1.7.7.jar:$KAFKA_LIB/snappy-java-1.0.5.jar:$KAFKA_LIB/zkclient-0.3.jar:$KAFKA_LIB/zookeeper-3.3.4.jar\n\n```", "```java\n[root@localhost kafka_2.9.2-0.8.1.1]# javac -d . kafka/examples/ch4/SimpleProducer.java\n\n```", "```java\n[root@localhost kafka_2.9.2-0.8.1.1]# java kafka.examples.ch4.SimpleProducer kafkatopic 10\n\n```", "```java\n[root@localhost kafka_2.9.2-0.8.1.1]# bin/kafka-console-consumer.sh --zookeeper localhost:2181 --from-beginning --topic kafkatopic\n\n```", "```java\nimport java.util.Date;\nimport java.util.Properties;\nimport java.util.Random;\n\nimport kafka.javaapi.producer.Producer;\nimport kafka.producer.KeyedMessage;\nimport kafka.producer.ProducerConfig;\n```", "```java\nProperties props = new Properties();\nprops.put(\"metadata.broker.list\",\"localhost:9092, localhost:9093, localhost:9094\");\nprops.put(\"serializer.class\",\"kafka.serializer.StringEncoder\"); \nprops.put(\"partitioner.class\", \"kafka.examples.ch4.SimplePartitioner\");\nprops.put(\"request.required.acks\", \"1\");\nProducerConfig config = new ProducerConfig(props); \nProducer<Integer, String> producer = new Producer<Integer, String>(config);\n```", "```java\npackage kafka.examples.ch4;\n\nimport kafka.producer.Partitioner;\n\npublic class SimplePartitioner implements Partitioner {\n\n  public SimplePartitioner (VerifiableProperties props) {\n\n  }\n\n  /*\n   * The method takes the key, which in this case is the IP address, \n   * It finds the last octet and does a modulo operation on the number \n   * of partitions defined within Kafka for the topic.\n   * \n   * @see kafka.producer.Partitioner#partition(java.lang.Object, int)\n   */\n  public int partition(Object key, int a_numPartitions) {\n    int partition = 0;\n    String partitionKey = (String) key;\n    int offset = partitionKey.lastIndexOf('.');\n    if (offset > 0) {\n      partition = Integer.parseInt(partitionKey.substring(offset + 1))\n          % a_numPartitions;\n    }\n    return partition;\n  }\n}\n```", "```java\npackage kafka.examples.ch4;\n\nimport java.util.Date;\nimport java.util.Properties;\nimport java.util.Random;\n\nimport kafka.javaapi.producer.Producer;\nimport kafka.producer.KeyedMessage;\nimport kafka.producer.ProducerConfig;\n\npublic class CustomPartitionProducer {\n  private static Producer<String, String> producer;\n\n  public CustomPartitionProducer() {\n    Properties props = new Properties();\n\n    // Set the broker list for requesting metadata to find the lead broker\n    props.put(\"metadata.broker.list\",\n          \"192.168.146.132:9092, 192.168.146.132:9093, 192.168.146.132:9094\");\n\n    // This specifies the serializer class for keys \n    props.put(\"serializer.class\", \"kafka.serializer.StringEncoder\");\n\n    // Defines the class to be used for determining the partition \n    // in the topic where the message needs to be sent.\n    props.put(\"partitioner.class\", \"kafka.examples.ch4.SimplePartitioner\");\n\n    // 1 means the producer receives an acknowledgment once the lead replica \n    // has received the data. This option provides better durability as the \n    // client waits until the server acknowledges the request as successful.\n    props.put(\"request.required.acks\", \"1\");\n\n    ProducerConfig config = new ProducerConfig(props);\n    producer = new Producer<String, String>(config);\n  }\n\n  public static void main(String[] args) {\n    int argsCount = args.length;\n    if (argsCount == 0 || argsCount == 1)\n      throw new IllegalArgumentException(\n        \"Please provide topic name and Message count as arguments\");\n\n    // Topic name and the message count to be published is passed from the\n    // command line\n    String topic = (String) args[0];\n    String count = (String) args[1];\n    int messageCount = Integer.parseInt(count);\n\n    System.out.println(\"Topic Name - \" + topic);\n    System.out.println(\"Message Count - \" + messageCount);\n\n    CustomPartitionProducer simpleProducer = new CustomPartitionProducer();\n    simpleProducer.publishMessage(topic, messageCount);\n  }\n\n  private void publishMessage(String topic, int messageCount) {\n    Random random = new Random();\n    for (int mCount = 0; mCount < messageCount; mCount++) {\n\n    String clientIP = \"192.168.14.\" + random.nextInt(255); \n    String accessTime = new Date().toString();\n\n    String message = accessTime + \",kafka.apache.org,\" + clientIP; \n      System.out.println(message);\n\n      // Creates a KeyedMessage instance\n      KeyedMessage<String, String> data = \n        new KeyedMessage<String, String>(topic, clientIP, message);\n\n      // Publish the message\n      producer.send(data);\n    }\n    // Close producer connection with broker.\n    producer.close();\n  }\n}\n```", "```java\n[root@localhost kafka_2.9.2-0.8.1.1]# bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 3 --partitions 5 --topic website-hits\n\n```", "```java\n[root@localhost kafka_2.9.2-0.8.1.1]# javac -d . kafka/examples/ch4/SimplePartitioner.java\n\n[root@localhost kafka_2.9.2-0.8.1.1]# javac -d . kafka/examples/ch4/CustomPartitionProducer.java\n\n```", "```java\n[root@localhost kafka_2.9.2-0.8.1.1]# java kafka.examples.ch4.CustomPartitionProducer website-hits 100\n\n```", "```java\n[root@localhost kafka_2.9.2-0.8.1.1]# bin/kafka-console-consumer.sh --zookeeper localhost:2181 --from-beginning --topic kafkatopic\n\n```"]