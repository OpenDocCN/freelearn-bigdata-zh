["```scala\npublic class SumFunction extends BaseFunction { \n\n  private static final long serialVersionUID = 5L; \n\n  public void execute(TridentTuple tuple, TridentCollector collector) { \n    int number1 = tuple.getInteger(0); \n    int number2 = tuple.getInteger(1); \n    int sum = number1+number2; \n    // emit the sum of first two fields \n    collector.emit(new Values(sum)); \n\n  } \n\n} \n```", "```scala\ndummyStream.each(new Fields(\"a\",\"b\"), new SumFunction (), new Fields(\"sum\")) \n```", "```scala\npublic static class CheckEvenSumFilter extends BaseFilter{ \n\n  private static final long serialVersionUID = 7L; \n\n  public boolean isKeep(TridentTuple tuple) { \n    int number1 = tuple.getInteger(0); \n    int number2 = tuple.getInteger(1); \n    int sum = number1+number2; \n    if(sum % 2 == 0) { \n      return true; \n    } \n    return false; \n  } \n\n} \n```", "```scala\ndummyStream.each(new Fields(\"a\",\"b\"), new CheckEvenSumFilter ()) \n```", "```scala\nmystream.project(new Fields(\"x\")) \n```", "```scala\nmystream.shuffle().each(new Fields(\"a\",\"b\"), new myFilter()).parallelismHint(2) \n```", "```scala\nmystream.partitionBy(new Fields(\"username\")).each(new Fields(\"username\",\"text\"), new myFilter()).parallelismHint(2) \n```", "```scala\nmystream.global().each(new Fields(\"a\",\"b\"), new myFilter()).parallelismHint(2) \n```", "```scala\nmystream.broadcast().each(new Fields(\"a\",\"b\"), new myFilter()).parallelismHint(2) \n```", "```scala\nmystream.batchGlobal().each(new Fields(\"a\",\"b\"), new myFilter()).parallelismHint(2) \n```", "```scala\npublic class CountryRepartition implements CustomStreamGrouping, Serializable { \n\n  private static final long serialVersionUID = 1L; \n\n  private static final Map<String, Integer> countries = ImmutableMap.of ( \n    \"India\", 0,  \n    \"Japan\", 1,  \n    \"United State\", 2,  \n    \"China\", 3, \n    \"Brazil\", 4 \n  ); \n\n  private int tasks = 0; \n\n  public void prepare(WorkerTopologyContext context, GlobalStreamId stream, List<Integer> targetTasks)  \n    { \n      tasks = targetTasks.size(); \n    } \n\n  public List<Integer> chooseTasks(int taskId, List<Object> values) { \n    String country = (String) values.get(0);    \n    return ImmutableList.of(countries.get(country) % tasks); \n  } \n} \n```", "```scala\nmystream.partitionAggregate(new Fields(\"x\"), new Count() ,new new Fields(\"count\")) \n```", "```scala\nmystream.aggregate(new Fields(\"x\"), new Count() ,new new Fields(\"count\")) \n```", "```scala\npublic static class Sum implements ReducerAggregator<Long> { \n\n  private static final long serialVersionUID = 1L; \n  /** return the initial value zero     \n  */ \n  public Long init() { \n    return 0L; \n  } \n  /** Iterates on the input tuples, calculate the sum and   \n  * produce the single tuple with single field as output. \n  */ \n  public Long reduce(Long curr, TridentTuple tuple) {                       \n    return curr+tuple.getLong(0);              \n  } \n\n} \n```", "```scala\npublic static class SumAsAggregator extends BaseAggregator<SumAsAggregator.State> { \n\n  private static final long serialVersionUID = 1L; \n  // state class \n  static class State { \n    long count = 0; \n  } \n  // Initialize the state \n  public State init(Object batchId, TridentCollector collector) { \n    return new State(); \n  } \n  // Maintain the state of sum into count variable.   \n  public void aggregate(State state, TridentTuple tridentTuple, TridentCollector tridentCollector) { \n    state.count = tridentTuple.getLong(0) + state.count; \n  } \n  // return a tuple with single value as output  \n  // after processing all the tuples of given batch.       \n  public void complete(State state, TridentCollector tridentCollector) { \n    tridentCollector.emit(new Values(state.count)); \n  } \n\n} \n```", "```scala\npublic class Sum implements CombinerAggregator<Number> { \n\n  private static final long serialVersionUID = 1L; \n\n  public Number init(TridentTuple tridentTuple) { \n    return (Number) tridentTuple.getValue(0); \n  } \n\n  public Number combine(Number number1, Number number2) { \n    return Numbers.add(number1, number2); \n  } \n\n  public Number zero() { \n    return 0; \n  } \n\n} \n```", "```scala\nmystream.persistentAggregate(new MemoryMapState.Factory(),new Fields(\"select\"),new Count(),new Fields(\"count\")); \n```", "```scala\nmystream.chainedAgg() \n        .partitionAggregate(new Fields(\"b\"), new Average(), new Fields(\"average\")) \n        .partitionAggregate(new Fields(\"b\"), new Sum(), new Fields(\"sum\")) \n        .chainEnd(); \n```"]