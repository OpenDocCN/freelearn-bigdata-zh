["```java\n<dependency> \n    <groupId>org.apache.flink</groupId> \n    <artifactId>flink-gelly_2.11</artifactId> \n    <version>1.1.4</version> \n</dependency> \n\n```", "```java\n<dependency> \n    <groupId>org.apache.flink</groupId> \n    <artifactId>flink-gelly-scala_2.11</artifactId> \n    <version>1.1.4</version> \n</dependency> \n\n```", "```java\n// A vertex with a Long ID and a String value \nVertex<Long, String> v = new Vertex<Long, String>(1L, \"foo\"); \n\n// A vertex with a Long ID and no value \nVertex<Long, NullValue> v = new Vertex<Long, NullValue>(1L, NullValue.getInstance()); \n\n```", "```java\n// A vertex with a Long ID and a String value \nval v = new Vertex(1L, \"foo\") \n\n// A vertex with a Long ID and no value \nval v = new Vertex(1L, NullValue.getInstance()) \n\n```", "```java\n// Edge connecting Vertices with Ids 1 and 2 having weight 0.5 \n\nEdge<Long, Double> e = new Edge<Long, Double>(1L, 2L, 0.5); \n\nDouble weight = e.getValue(); // weight = 0.5 \n\n```", "```java\n// Edge connecting Vertices with Ids 1 and 2 having weight 0.5 \n\nval e = new Edge(1L, 2L, 0.5) \n\nval weight = e.getValue // weight = 0.5 \n\n```", "```java\n// A vertex with a Long ID and a String value \nVertex<Long, String> v1 = new Vertex<Long, String>(1L, \"foo\"); \n\n// A vertex with a Long ID and a String value \nVertex<Long, String> v2 = new Vertex<Long, String>(2L, \"bar\"); \n\n// Edge connecting Vertices with Ids 1 and 2 having weight 0.5 \n\nEdge<Long, Double> e = new Edge<Long, Double>(1L, 2L, 0.5); \n\n```", "```java\n// A vertex with a Long ID and a String value \nval v1 = new Vertex(1L, \"foo\") \n\n// A vertex with a Long ID and a String value \nval v2 = new Vertex(1L, \"bar\") \n\n// Edge connecting Vertices with Ids 1 and 2 having weight 0.5 \n\nval e = new Edge(1L, 2L, 0.5) \n\n```", "```java\n// A vertex with a Long ID and a String value \nVertex<Long, String> v1 = new Vertex<Long, String>(1L, \"foo\"); \n\n// A vertex with a Long ID and a String value \nVertex<Long, String> v2 = new Vertex<Long, String>(2L, \"bar\"); \n\n// Edges connecting Vertices with Ids 1 and 2 having weight 0.5 \n\nEdge<Long, Double> e1 = new Edge<Long, Double>(1L, 2L, 0.5); \n\nEdge<Long, Double> e2 = new Edge<Long, Double>(2L, 1L, 0.5); \n\n```", "```java\n// A vertex with a Long ID and a String value \nval v1 = new Vertex(1L, \"foo\") \n\n// A vertex with a Long ID and a String value \nval v2 = new Vertex(1L, \"bar\") \n\n// Edges connecting Vertices with Ids 1 and 2 having weight 0.5 \n\nval e1 = new Edge(1L, 2L, 0.5) \n\nval e2 = new Edge(2L, 1L, 0.5) \n\n```", "```java\nExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment(); \n\nDataSet<Vertex<String, Long>> vertices = ... \n\nDataSet<Edge<String, Double>> edges = ... \n\nGraph<String, Long, Double> graph = Graph.fromDataSet(vertices, edges, env); \n\n```", "```java\nval env = ExecutionEnvironment.getExecutionEnvironment \n\nval vertices: DataSet[Vertex[String, Long]] = ... \n\nval edges: DataSet[Edge[String, Double]] = ... \n\nval graph = Graph.fromDataSet(vertices, edges, env) \n\n```", "```java\nExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment(); \n\nDataSet<Tuple2<String, String>> edges = ... \n\nGraph<String, NullValue, NullValue> graph = Graph.fromTuple2DataSet(edges, env); \n\n```", "```java\nval env = ExecutionEnvironment.getExecutionEnvironment \n\nval edges: DataSet[(String, String)] = ... \n\nval graph = Graph.fromTuple2DataSet(edges, env) \n\n```", "```java\nExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment(); \n\nDataSet<Tuple2<String, Long>> vertexTuples = env.readCsvFile(\"path/to/vertex/input.csv\").types(String.class, Long.class); \n\nDataSet<Tuple3<String, String, Double>> edgeTuples = env.readCsvFile(\"path/to/edge/input.csv\").types(String.class, String.class, Double.class); \n\nGraph<String, Long, Double> graph = Graph.fromTupleDataSet(vertexTuples, edgeTuples, env); \n\n```", "```java\nval env = ExecutionEnvironment.getExecutionEnvironment \n\nval vertexTuples = env.readCsvFile[String, Long](\"path/to/vertex/input.csv\") \n\nval edgeTuples = env.readCsvFile[String, String, Double](\"path/to/edge/input.csv\") \n\nval graph = Graph.fromTupleDataSet(vertexTuples, edgeTuples, env) \n\n```", "```java\nval env = ExecutionEnvironment.getExecutionEnvironment \n\n// create a Graph with String Vertex IDs, Long Vertex values and Double Edge values \nval graph = Graph.fromCsvReader[String, Long, Double]( \n    pathVertices = \"path/to/vertex/input.csv\", \n    pathEdges = \"path/to/edge/input.csv\", \n    env = env) \n\n```", "```java\nval simpleGraph = Graph.fromCsvReader[Long, Double, NullValue]( \n        pathEdges = \"path/to/edge/input.csv\", \n        vertexValueInitializer = new MapFunction[Long, Double]() { \n            def map(id: Long): Double = { \n                id.toDouble \n            } \n        }, \n        env = env) \n\n```", "```java\nExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment(); \n\nList<Vertex<Long, Long>> vertexList = new ArrayList... \n\nList<Edge<Long, String>> edgeList = new ArrayList... \n\nGraph<Long, Long, String> graph = Graph.fromCollection(vertexList, edgeList, env); \n\n```", "```java\nval env = ExecutionEnvironment.getExecutionEnvironment \n\nval vertexList = List(...) \n\nval edgeList = List(...) \n\nval graph = Graph.fromCollection(vertexList, edgeList, env) \n\n```", "```java\nval env = ExecutionEnvironment.getExecutionEnvironment \n\n// initialize the vertex value to be equal to the vertex ID \nval graph = Graph.fromCollection(edgeList, \n    new MapFunction[Long, Long] { \n       def map(id: Long): Long = id \n    }, env)\n```", "```java\nExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment(); \nGraph<Long, Long, Long> graph = Graph.fromDataSet(vertices, edges, env); \n\n// increment each vertex value by 5 \nGraph<Long, Long, Long> updatedGraph = graph.mapVertices( \n        new MapFunction<Vertex<Long, Long>, Long>() { \n          public Long map(Vertex<Long, Long> value) { \n            return value.getValue() + 5; \n          } \n        }); \n\n```", "```java\nval env = ExecutionEnvironment.getExecutionEnvironment \nval graph = Graph.fromDataSet(vertices, edges, env) \n\n// increment each vertex value by 5 \nval updatedGraph = graph.mapVertices(v => v.getValue + 5) \n\n```", "```java\n// translate each vertex and edge ID to a String \nGraph<String, Long, Long> updatedGraph = graph.translateGraphIds( \n        new MapFunction<Long, String>() { \n          public String map(Long id) { \n            return id.toString(); \n          } \n        }); \n\n// translate vertex IDs, edge IDs, vertex values, and edge values to LongValue \nGraph<LongValue, LongValue, LongValue> updatedGraph = graph \n                .translateGraphIds(new LongToLongValue()) \n                .translateVertexValues(new LongToLongValue()) \n                .translateEdgeValues(new LongToLongValue()) \n\n```", "```java\n// translate each vertex and edge ID to a String \nval updatedGraph = graph.translateGraphIds(id => id.toString) \n\n```", "```java\nGraph<Long, Long, Long> graph = ... \n\ngraph.subgraph( \n    new FilterFunction<Vertex<Long, Long>>() { \n           public boolean filter(Vertex<Long, Long> vertex) { \n          // keep only vertices with positive values \n          return (vertex.getValue() > 2); \n         } \n       }, \n    new FilterFunction<Edge<Long, Long>>() { \n        public boolean filter(Edge<Long, Long> edge) { \n          // keep only edges with negative values \n          return (edge.getTarget() == 3); \n        } \n    }) \n\n```", "```java\nval graph: Graph[Long, Long, Long] = ... \ngraph.subgraph((vertex => vertex.getValue > 2), (edge => edge.getTarget == 3)) \n\n```", "```java\nGraph<Long, Double, Double> network = ... \n\nDataSet<Tuple2<Long, LongValue>> vertexOutDegrees = network.outDegrees(); \n\n// assign the transition probabilities as the edge weights \nGraph<Long, Double, Double> networkWithWeights = network.joinWithEdgesOnSource(vertexOutDegrees, \n        new VertexJoinFunction<Double, LongValue>() { \n          public Double vertexJoin(Double vertexValue, LongValue inputValue) { \n            return vertexValue / inputValue.getValue(); \n          } \n        }); \n\n```", "```java\nval network: Graph[Long, Double, Double] = ... \n\nval vertexOutDegrees: DataSet[(Long, LongValue)] = network.outDegrees \n// assign the transition probabilities as the edge weights \n\nval networkWithWeights = network.joinWithEdgesOnSource(vertexOutDegrees, (v1: Double, v2: LongValue) => v1 / v2.getValue) \n\n```", "```java\nGraph<Long, Double, Double> network = ...; \nGraph<Long, Double, Double> networkReverse  = network.reverse(); \n\n```", "```java\nval network: Graph[Long, Double, Double] = ... \nval networkReversed: Graph[Long, Double, Double] = network.reverse  \n\n```", "```java\nGraph<Long, Double, Double> network = ...; \nGraph<Long, Double, Double> networkUD  = network.undirected(); \n\n```", "```java\nval network: Graph[Long, Double, Double] = ... \nval networkUD: Graph[Long, Double, Double] = network.undirected \n\n```", "```java\nExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment(); \n\n// create first graph from edges {(1, 2, 10) (1, 2, 11), (1, 2, 10)} \nList<Edge<Long, Long>> edges1 = ... \nGraph<Long, NullValue, Long> graph1 = Graph.fromCollection(edges1, env); \n\n// create second graph from edges {(1, 2, 10)} \nList<Edge<Long, Long>> edges2 = ... \nGraph<Long, NullValue, Long> graph2 = Graph.fromCollection(edges2, env); \n\n// Using distinct = true results in {(1,2,10)} \nGraph<Long, NullValue, Long> intersect1 = graph1.intersect(graph2, true); \n\n// Using distinct = false results in {(1,2,10),(1,2,10)} as there is one edge pair \nGraph<Long, NullValue, Long> intersect2 = graph1.intersect(graph2, false); \n\n```", "```java\nval env = ExecutionEnvironment.getExecutionEnvironment \n\n// create first graph from edges {(1, 2, 10) (1, 2, 11), (1, 2, 10)} \nval edges1: List[Edge[Long, Long]] = ... \nval graph1 = Graph.fromCollection(edges1, env) \n\n// create second graph from edges {(1, 2, 10)} \nval edges2: List[Edge[Long, Long]] = ... \nval graph2 = Graph.fromCollection(edges2, env) \n\n// Using distinct = true results in {(1,2,10)} \nval intersect1 = graph1.intersect(graph2, true) \n\n// Using distinct = false results in {(1,2,10),(1,2,10)} as there is one edge pair \nval intersect2 = graph1.intersect(graph2, false) \n\n```", "```java\nGraph<Long, Long, Double> graph = ... \n\nDataSet<Tuple2<Long, Double>> maxWeights = graph.reduceOnEdges(new SelectMaxWeight(), EdgeDirection.OUT); \n\n// user-defined function to select the max weight \nstatic final class SelectMaxWeight implements ReduceEdgesFunction<Double> { \n\n    @Override \n    public Double reduceEdges(Double firstEdgeValue, Double secondEdgeValue) { \n      return Math.max(firstEdgeValue, secondEdgeValue); \n    } \n} \n\n```", "```java\nval graph: Graph[Long, Long, Double] = ... \n\nval minWeights = graph.reduceOnEdges(new SelectMaxWeight, EdgeDirection.OUT) \n\n// user-defined function to select the max weight \nfinal class SelectMaxWeight extends ReduceEdgesFunction[Double] { \n  override def reduceEdges(firstEdgeValue: Double, secondEdgeValue: Double): Double = { \n    Math.max(firstEdgeValue, secondEdgeValue) \n  } \n } \n\n```", "```java\nGraph<Long, Long, Double> graph = ... \n\nDataSet<Tuple2<Long, Long>> verticesWithSum = graph.reduceOnNeighbors(new SumValues(), EdgeDirection.IN); \n\nstatic final class SumValues implements ReduceNeighborsFunction<Long> { \n\n        @Override \n        public Long reduceNeighbors(Long firstNeighbor, Long secondNeighbor) { \n          return firstNeighbor + secondNeighbor; \n      } \n} \n\n```", "```java\nval graph: Graph[Long, Long, Double] = ... \n\nval verticesWithSum = graph.reduceOnNeighbors(new SumValues, EdgeDirection.IN) \n\nfinal class SumValues extends ReduceNeighborsFunction[Long] { \n     override def reduceNeighbors(firstNeighbor: Long, secondNeighbor: Long): Long = { \n      firstNeighbor + secondNeighbor \n    } \n} \n\n```", "```java\nGraph<Long, Long, Long> graph = Graph.fromCollection(vertices, edges, env); \n\n// Returns false for invalid vertex id.  \ngraph.validate(new InvalidVertexIdsValidator<Long, Long, Long>()); \n\n```", "```java\nval graph = Graph.fromCollection(vertices, edges, env) \n\n// Returns false for invalid vertex id.  \ngraph.validate(new InvalidVertexIdsValidator[Long, Long, Long]) \n\n```", "```java\n// maximum number of iterations \nint maxIterations = 5; \n\n// Run vertex-centric iteration \nGraph<Long, Double, Double> result = graph.runVertexCentricIteration( \n            new SSSPComputeFunction(), new SSSPCombiner(), maxIterations); \n\n// Extract the vertices as the result \nDataSet<Vertex<Long, Double>> singleSourceShortestPaths = result.getVertices(); \n\n//User defined compute function to minimize the distance between //the vertices \n\npublic static final class SSSPComputeFunction extends ComputeFunction<Long, Double, Double, Double> { \n\npublic void compute(Vertex<Long, Double> vertex, MessageIterator<Double> messages) { \n\n    double minDistance = (vertex.getId().equals(srcId)) ? 0d : Double.POSITIVE_INFINITY; \n\n    for (Double msg : messages) { \n        minDistance = Math.min(minDistance, msg); \n    } \n\n    if (minDistance < vertex.getValue()) { \n        setNewVertexValue(minDistance); \n        for (Edge<Long, Double> e: getEdges()) { \n            sendMessageTo(e.getTarget(), minDistance + e.getValue()); \n        } \n    } \n} \n\n// message combiner helps in optimizing the communications \npublic static final class SSSPCombiner extends MessageCombiner<Long, Double> { \n\n    public void combineMessages(MessageIterator<Double> messages) { \n\n        double minMessage = Double.POSITIVE_INFINITY; \n        for (Double msg: messages) { \n           minMessage = Math.min(minMessage, msg); \n        } \n        sendCombinedMessage(minMessage); \n    } \n} \n\n```", "```java\n// maximum number of iterations \nval maxIterations = 5 \n\n// Run the vertex-centric iteration \nval result = graph.runVertexCentricIteration(new SSSPComputeFunction, new SSSPCombiner, maxIterations) \n\n// Extract the vertices as the result \nval singleSourceShortestPaths = result.getVertices \n\n//User defined compute function to minimize the distance between //the vertices \n\nfinal class SSSPComputeFunction extends ComputeFunction[Long, Double, Double, Double] { \n\n    override def compute(vertex: Vertex[Long, Double], messages:   \n    MessageIterator[Double]) = { \n\n    var minDistance = if (vertex.getId.equals(srcId)) 0 else  \n    Double.MaxValue \n\n    while (messages.hasNext) { \n        val msg = messages.next \n        if (msg < minDistance) { \n            minDistance = msg \n        } \n    } \n\n    if (vertex.getValue > minDistance) { \n        setNewVertexValue(minDistance) \n        for (edge: Edge[Long, Double] <- getEdges) { \n            sendMessageTo(edge.getTarget, vertex.getValue +  \n            edge.getValue) \n        } \n    } \n} \n\n// message combiner helps in optimizing the communications \nfinal class SSSPCombiner extends MessageCombiner[Long, Double] { \n\n    override def combineMessages(messages: MessageIterator[Double]) { \n\n        var minDistance = Double.MaxValue \n\n        while (messages.hasNext) { \n          val msg = inMessages.next \n          if (msg < minDistance) { \n            minDistance = msg \n          } \n        } \n        sendCombinedMessage(minMessage) \n    } \n} \n\n```", "```java\n// maximum number of iterations \nint maxIterations = 5; \n\n// Run the scatter-gather iteration \nGraph<Long, Double, Double> result = graph.runScatterGatherIteration( \n      new MinDistanceMessenger(), new VertexDistanceUpdater(), maxIterations); \n\n// Extract the vertices as the result \nDataSet<Vertex<Long, Double>> singleSourceShortestPaths = result.getVertices(); \n\n// Scatter Gather function definition  \n\n// Through scatter function, we send distances from each vertex \npublic static final class MinDistanceMessenger extends ScatterFunction<Long, Double, Double, Double> { \n\n  public void sendMessages(Vertex<Long, Double> vertex) { \n    for (Edge<Long, Double> edge : getEdges()) { \n      sendMessageTo(edge.getTarget(), vertex.getValue() + edge.getValue()); \n    } \n  } \n} \n\n// In gather function, we gather messages sent in previous //superstep to find out the minimum distance.  \npublic static final class VertexDistanceUpdater extends GatherFunction<Long, Double, Double> { \n\n  public void updateVertex(Vertex<Long, Double> vertex, MessageIterator<Double> inMessages) { \n    Double minDistance = Double.MAX_VALUE; \n\n    for (double msg : inMessages) { \n      if (msg < minDistance) { \n        minDistance = msg; \n      } \n    } \n\n    if (vertex.getValue() > minDistance) { \n      setNewVertexValue(minDistance); \n    } \n  } \n} \n\n```", "```java\n// maximum number of iterations \nval maxIterations = 5 \n\n// Run the scatter-gather iteration \nval result = graph.runScatterGatherIteration(new MinDistanceMessenger, new VertexDistanceUpdater, maxIterations) \n\n// Extract the vertices as the result \nval singleSourceShortestPaths = result.getVertices \n\n// Scatter Gather definitions \n\n// Through scatter function, we send distances from each vertex \nfinal class MinDistanceMessenger extends ScatterFunction[Long, Double, Double, Double] { \n\n  override def sendMessages(vertex: Vertex[Long, Double]) = { \n    for (edge: Edge[Long, Double] <- getEdges) { \n      sendMessageTo(edge.getTarget, vertex.getValue + edge.getValue) \n    } \n  } \n} \n\n// In gather function, we gather messages sent in previous //superstep to find out the minimum distance.  \nfinal class VertexDistanceUpdater extends GatherFunction[Long, Double, Double] { \n\n  override def updateVertex(vertex: Vertex[Long, Double], inMessages: MessageIterator[Double]) = { \n    var minDistance = Double.MaxValue \n\n    while (inMessages.hasNext) { \n      val msg = inMessages.next \n      if (msg < minDistance) { \n      minDistance = msg \n      } \n    } \n\n    if (vertex.getValue > minDistance) { \n      setNewVertexValue(minDistance) \n    } \n  } \n} \n\n```", "```java\n// maximum number of iterations \nint maxIterations = 5; \n\n// Run the GSA iteration \nGraph<Long, Double, Double> result = graph.runGatherSumApplyIteration( \n        new CalculateDistances(), new ChooseMinDistance(), new UpdateDistance(), maxIterations); \n\n// Extract the vertices as the result \nDataSet<Vertex<Long, Double>> singleSourceShortestPaths = result.getVertices(); \n\n// Functions for GSA \n\n// Gather \nprivate static final class CalculateDistances extends GatherFunction<Double, Double, Double> { \n\n  public Double gather(Neighbor<Double, Double> neighbor) { \n    return neighbor.getNeighborValue() + neighbor.getEdgeValue(); \n  } \n} \n\n// Sum \nprivate static final class ChooseMinDistance extends SumFunction<Double, Double, Double> { \n\n  public Double sum(Double newValue, Double currentValue) { \n    return Math.min(newValue, currentValue); \n  } \n} \n\n// Apply \nprivate static final class UpdateDistance extends ApplyFunction<Long, Double, Double> { \n\n  public void apply(Double newDistance, Double oldDistance) { \n    if (newDistance < oldDistance) { \n      setResult(newDistance); \n    } \n  } \n} \n\n```", "```java\n// maximum number of iterations \nval maxIterations = 10 \n\n// Run the GSA iteration \nval result = graph.runGatherSumApplyIteration(new CalculateDistances, new ChooseMinDistance, new UpdateDistance, maxIterations) \n\n// Extract the vertices as the result \nval singleSourceShortestPaths = result.getVertices \n\n// Custom function for GSA \n\n// Gather \nfinal class CalculateDistances extends GatherFunction[Double, Double, Double] { \n\n  override def gather(neighbor: Neighbor[Double, Double]): Double = { \n    neighbor.getNeighborValue + neighbor.getEdgeValue \n  } \n} \n\n// Sum \nfinal class ChooseMinDistance extends SumFunction[Double, Double, Double] { \n\n  override def sum(newValue: Double, currentValue: Double): Double = { \n    Math.min(newValue, currentValue) \n  } \n} \n\n// Apply \nfinal class UpdateDistance extends ApplyFunction[Long, Double, Double] { \n\n  override def apply(newDistance: Double, oldDistance: Double) = { \n    if (newDistance < oldDistance) { \n      setResult(newDistance) \n    } \n  } \n} \n\n```", "```java\n// set up the batch execution environment \nfinal ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment(); \n\n// Create graph by reading from CSV files \nDataSet<Tuple2<String, Double>> airportVertices = env \n            .readCsvFile(\"nodes.csv\").types(String.class, Double.class); \n\nDataSet<Tuple3<String, String, Double>> airportEdges = env \n            .readCsvFile(\"edges.csv\") \n            .types(String.class, String.class, Double.class); \n\nGraph<String, Double, Double> graph = Graph.fromTupleDataSet(airportVertices, airportEdges, env); \n\n```", "```java\n// define the maximum number of iterations\nint maxIterations = 10;\n\n// Execute the vertex-centric iteration\nGraph<String, Double, Double> result = graph.runVertexCentricIteration(new SSSPComputeFunction(), new SSSPCombiner(), maxIterations);\n\n// Extract the vertices as the result\nDataSet<Vertex<String, Double>> singleSourceShortestPaths = result.getVertices();\nsingleSourceShortestPaths.print();\n```"]