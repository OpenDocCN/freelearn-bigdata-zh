["```scala\nminiMax (board, depth, maximizing)\n   if (depth <= 0) \n      return score (board)\n   else\n      children = move(board)\n      if (maximizing)\n         bestValue = -\u221e\n      for (child : children)\n         value = miniMax (child, depth-1, false)\n         if (value > bestValue)\n            bestValue = value\n         end\nend\nreturn bestValue\n      else // minimizing\n         bestValue = \u221e\n      for (child : children)\n         value = miniMax (child, depth-1, false)\n         if (value < bestValue)\n            bestValue = value\n         end\nend\nreturn bestValue\nend\nend\n```", "```scala\n(board, parents[])\n```", "```scala\npublic class Board implements Serializable {\npublic static final String EMPTY = ' ';\n   public String[][] board = { { EMPTY, EMPTY, EMPTY },\n{ EMPTY, EMPTY, EMPTY }, { EMPTY, EMPTY, EMPTY } };\n\npublic List<Board> nextBoards(String player) {\n        List<Board> boards = new ArrayList<Board>();\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                if (board[i][j].equals(EMPTY)) {\n                    Board newBoard = this.clone();\n                    newBoard.board[i][j] = player;\n                    boards.add(newBoard);\n                }\n            }\n        }\n        return boards;\n    }\n\n    public boolean isEndState() {\n        return (nextBoards('X').size() == 0 \n|| Math.abs(score('X')) > 1000);\n    }\n\n    public int score(String player){\n        return scoreLines(player) \u2013 \n            scoreLines(Player.next(player));\n    }\n\n    public int scoreLines(String player) {\n        int score = 0;\n        // Columns\n        score += scoreLine(board[0][0], board[1][0], board[2][0], player);\n        score += scoreLine(board[0][1], board[1][1], board[2][1], player);\n        score += scoreLine(board[0][2], board[1][2], board[2][2], player);\n\n        // Rows\n        score += scoreLine(board[0][0], board[0][1], board[0][2], player);\n        score += scoreLine(board[1][0], board[1][1], board[1][2], player);\n        score += scoreLine(board[2][0], board[2][1], board[2][2], player);\n\n       // Diagonals\n        score += scoreLine(board[0][0], board[1][1], board[2][2], player);\n        score += scoreLine(board[2][0], board[1][1], board[0][2], player);\n        return score;\n    }\n\n    public int scoreLine(String pos1, String pos2, String pos3, String player) {\n        int score = 0;\n        if (pos1.equals(player) && pos2.equals(player) && pos3.equals(player)) {\n            score = 10000;\n        } else if ((pos1.equals(player) && pos2.equals(player) && pos3.equals(EMPTY)) ||\n                (pos1.equals(EMPTY) && pos2.equals(player) && pos3.equals(player)) ||\n                (pos1.equals(player) && pos2.equals(EMPTY) && pos3.equals(player))) {\n            score = 100;\n        } else {\n            if (pos1.equals(player) && pos2.equals(EMPTY) && pos3.equals(EMPTY) ||\n                    pos1.equals(EMPTY) && pos2.equals(player) && pos3.equals(EMPTY) ||\n                    pos1.equals(EMPTY) && pos2.equals(EMPTY) && pos3.equals(player)){\n                score = 10;\n            }\n        }\n        return score;\n    }\n...\n    public String toKey() {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                sb.append(board[i][j]);\n            }\n        }\n        return sb.toString();\n    }\n}\n```", "```scala\npublic class GameState implements Serializable {\nprivate Board board;\n    private List<Board> history;\n    private String player;\n\n...\n\n    public String toString(){\n        StringBuilder sb = new StringBuilder('GAME [');\n        sb.append(board.toKey()).append(']');\n        sb.append(': player(').append(player).append(')\\n');\n        sb.append('   history [');\n        for (Board b : history){\n            sb.append(b.toKey()).append(',');\n        }\n        sb.append(']');\n        return sb.toString();\n    }\n}\n```", "```scala\npublic class Player {\n    public static String next(String current){\n        if (current.equals('X')) return 'O';\n        else return 'X';\n    }\n}\n```", "```scala\npublic class RecursiveTopology {\n\n    public static StormTopology buildTopology() {\n        LOG.info('Building topology.');\n        TridentTopology topology = new TridentTopology();\n\n        // Work Queue / Spout\n        LocalQueueEmitter<GameState> workSpoutEmitter = \nnew LocalQueueEmitter<GameState>('WorkQueue');\n        LocalQueueSpout<GameState> workSpout = \nnew LocalQueueSpout<GameState>(workSpoutEmitter);\n        GameState initialState = \nnew GameState(new Board(),\nnew ArrayList<Board>(), 'X');\n        workSpoutEmitter.enqueue(initialState);\n\n        // Scoring Queue / Spout\n        LocalQueueEmitter<GameState> scoringSpoutEmitter = \nnew LocalQueueEmitter<GameState>('ScoringQueue');\n\n        Stream inputStream = \ntopology.newStream('gamestate', workSpout);\n\n        inputStream.each(new Fields('gamestate'),\nnew isEndGame())\n                .each(new Fields('gamestate'),\n                    new LocalQueuerFunction<GameState>(scoringSpoutEmitter),\u2029 new Fields(''));\n\n        inputStream.each(new Fields('gamestate'),\nnew GenerateBoards(),\nnew Fields('children'))\n            .each(new Fields('children'),\n                    new LocalQueuerFunction<GameState>(workSpoutEmitter),\n                    new Fields());\n\n        return topology.build();\n    }\n...\n}\n```", "```scala\npublic class LocalQueueEmitter<T> implements Emitter<Long>, Serializable {\npublic static final int MAX_BATCH_SIZE=1000;\npublic static AtomicInteger successfulTransactions = \nnew AtomicInteger(0);\n    private static Map<String, BlockingQueue<Object>> queues =\n new HashMap<String, BlockingQueue<Object>>();\nprivate static final Logger LOG = \nLoggerFactory.getLogger(LocalQueueEmitter.class);\n    private String queueName;\n\n    public LocalQueueEmitter(String queueName) {\n        queues.put(queueName, new LinkedBlockingQueue<Object>());\n        this.queueName = queueName;\n    }\n\n    @Override\n    public void emitBatch(TransactionAttempt tx,\n Long coordinatorMeta, TridentCollector collector) {\n        int size=0;\n        LOG.debug('Getting batch for [' +\n tx.getTransactionId() + ']');\n        while (getQueue().peek() != null && \nsize <= MAX_BATCH_SIZE) {\n            List<Object> values = new ArrayList<Object>();\n            try {\n                LOG.debug('Waiting on work from [' +\n this.queueName + ']:[' + \ngetQueue().size() + ']');\n                values.add(getQueue().take());\n                LOG.debug('Got work from [' + \nthis.queueName + ']:[' + \ngetQueue().size() + ']');\n            } catch (InterruptedException ex) {\n                // do something smart\n            }\n            collector.emit(values);\n            size++;\n        }\n        LOG.info('Emitted [' + size + '] elements in [' + \n            tx.getTransactionId() + '], [' + getQueue().size()\n+ '] remain in queue.');\n    }\n...\n    public void enqueue(T work) {\n        LOG.debug('Adding work to [' + this.queueName +\n ']:[' + getQueue().size() + ']');\n        if (getQueue().size() % 1000 == 0)\n            LOG.info('[' + this.queueName + '] size = [' + \n\t\t\tgetQueue().size() + '].');\n        this.getQueue().add(work);\n    }\n\n    public BlockingQueue<Object> getQueue() {\n        return LocalQueueEmitter.queues.get(this.queueName);\n    }\n...\n}\n```", "```scala\npublic class LocalQueuerFunction<T>  extends BaseFunction {\n    private static final long serialVersionUID = 1L;\n    LocalQueueEmitter<T> emitter;\n\n    public LocalQueuerFunction(LocalQueueEmitter<T> emitter){\n        this.emitter = emitter;\n    }\n\n    @SuppressWarnings('unchecked')\n    @Override\n    public void execute(TridentTuple tuple, TridentCollector collector) {\n        T object = (T) tuple.get(0);\n        Log.debug('Queueing [' + object + ']');\n        this.emitter.enqueue(object);\n    }\n}\n```", "```scala\npublic class IsEndGame extends BaseFilter {\n...\n    @Override\n    public boolean isKeep(TridentTuple tuple) {\n        GameState gameState = (GameState) tuple.get(0);\n        boolean keep = (gameState.getBoard().isEndState());\n        if (keep){\n            LOG.debug('END GAME [' + gameState + ']');\n        }\n        return keep;\n    }\n}\n```", "```scala\npublic class GenerateBoards extends BaseFunction {\n\n    @Override\n    public void execute(TridentTuple tuple,\nTridentCollector collector) {\n        GameState gameState = (GameState) tuple.get(0);\n        Board currentBoard = gameState.getBoard();\n        List<Board> history = new ArrayList<Board>();\n        history.addAll(gameState.getHistory());\n        history.add(currentBoard);\n\n        if (!currentBoard.isEndState()) {\n            String nextPlayer = \n\t\t\tPlayer.next(gameState.getPlayer());\n            List<Board> boards = \n\t\t\tgameState.getBoard().nextBoards(nextPlayer);\n            Log.debug('Generated [' + boards.size() + \n'] children boards for [' + gameState.toString() +\n']');\n            for (Board b : boards) {\n                GameState newGameState = \nnew GameState(b, history, nextPlayer);\n                List<Object> values = new ArrayList<Object>();\n                values.add(newGameState);\n                collector.emit(values);\n            }\n        } else {\n            Log.debug('End game found! [' + currentBoard + ']');\n        }\n    }\n}\n```", "```scala\n2013-12-30 21:53:40,940-0500 | INFO [Thread-28] IsEndGame.isKeep(20) | END GAME [GAME [XXO X OOO]: player(O)\n   history [         ,      O  ,    X O  ,    X OO ,X   X OO ,X O X OO ,XXO X OO ,]]\n2013-12-30 21:53:40,940-0500 | INFO [Thread-28] IsEndGame.isKeep(20) | END GAME [GAME [X OXX OOO]: player(O)\n   history [         ,      O  ,    X O  ,    X OO ,X   X OO ,X O X OO ,X OXX OO ,]]\n2013-12-30 21:53:40,940-0500 | INFO [Thread-28] LocalQueueEmitter.enqueue(61) | [ScoringQueue] size = [42000]\n```", "```scala\npublic static StormTopology buildTopology() {\nTridentTopology topology = new TridentTopology();\n\nGameState exampleRecursiveState =\n GameState.playAtRandom(new Board(), 'X');\nLOG.info('SIMULATED STATE : [' + exampleRecursiveState + ']');\n\n// Scoring Queue / Spout\nLocalQueueEmitter<GameState> scoringSpoutEmitter = \nnew LocalQueueEmitter<GameState>('ScoringQueue');\nscoringSpoutEmitter.enqueue(exampleRecursiveState);\nLocalQueueSpout<GameState> scoringSpout = \nnew LocalQueueSpout<GameState>(scoringSpoutEmitter);\n\nStream inputStream = \ntopology.newStream('gamestate', scoringSpout);\n\ninputStream.each(new Fields('gamestate'), new IsEndGame())\n                .each(new Fields('gamestate'),\n                        new ScoreFunction(),\n                        new Fields('board', 'score', 'player'))\n                .each(new Fields('board', 'score', 'player'), \nnew ScoreUpdater(), new Fields());\nreturn topology.build();\n}\n```", "```scala\npublic class ScoreFunction extends BaseFunction {\n\n@Override\npublic void execute(TridentTuple tuple, \nTridentCollector collector) {\n        GameState gameState = (GameState) tuple.get(0);\n        String player = gameState.getPlayer();\n        int score = gameState.score();\n\n        List<Object> values = new ArrayList<Object>();\n        values.add(gameState.getBoard());\n        values.add(score);\n        values.add(player);\n        collector.emit(values);\n\n        for (Board b : gameState.getHistory()) {\n            player = Player.next(player);\n            values = new ArrayList<Object>();\n            values.add(b);\n            values.add(score);\n            values.add(player);\n            collector.emit(values);\n        }\n    }\n}\n```", "```scala\npublic class ScoreUpdater extends BaseFunction {\n...\nprivate static final Map<String, Integer> scores =\n new HashMap<String, Integer>();\nprivate static final String MUTEX = 'MUTEX';\n\n@Override\npublic void execute(TridentTuple tuple,\nTridentCollector collector) {\n    Board board = (Board) tuple.get(0);\n    int score = tuple.getInteger(1);\n    String player = tuple.getString(2);\n    String key = board.toKey();\n    LOG.debug('Got (' + board.toKey() + ') => [' + score +\n '] for [' + player + ']');\n\n    // Always compute things from X's perspective\n    // We'll flip things when we interpret it if it is O's turn.\n    synchronized(MUTEX){\n         Integer currentScore = scores.get(key);\n         if (currentScore == null ||\n(player.equals('X') && score > currentScore)){\n                updateScore(board, score);\n            } else if (player.equals('O') &&\nscore > currentScore){\n                updateScore(board, score);\n            }\n        }\n    }\n\n    public void updateScore(Board board, Integer score){\n        scores.put(board.toKey(), score);\n        LOG.debug('Updating [' + board.toString() + \n']=>[' + score + ']');\n    }\n}\n```", "```scala\nUPDATE gametree SET score=7 WHERE\nboardkey = '000XX OXX' AND score <=7;\n```", "```scala\n2013-12-31 13:19:14,535-0500 | INFO [main] ScoringTopology.buildTopology(29) | SIMULATED LEAF NODE : [\n---------\n|X||O||X|\n---------\n|O||O||X|\n---------\n|X||X||O|\n---------\n] w/ state [GAME [XOXOOXXXO]: player(O)\n history [         ,  X      , OX      , OX  X   , OX  X  O, OX  XX O, OXO XX O, OXO XXXO, OXOOXXXO,]]\n2013-12-31 13:19:14,536-0500 | INFO [main] LocalQueueEmitter.enqueue(61) | [ScoringQueue] size = [0].\n2013-12-31 13:19:14,806-0500 | INFO [main] ScoringTopology.main(52) | Topology submitted.\n2013-12-31 13:19:25,566-0500 | INFO [Thread-24] DefaultCoordinator.initializeTransaction(25) | Initializing Transaction [1]\n2013-12-31 13:19:25,570-0500 | DEBUG [Thread-30] LocalQueueEmitter.emitBatch(37) | Getting batch for [1]\n2013-12-31 13:19:25,570-0500 | DEBUG [Thread-30] LocalQueueEmitter.emitBatch(41) | Waiting on work from [ScoringQueue]:[1]\n2013-12-31 13:19:25,570-0500 | DEBUG [Thread-30] LocalQueueEmitter.emitBatch(43) | Got work from [ScoringQueue]:[0]\n2013-12-31 13:19:25,571-0500 | DEBUG [Thread-30] LocalQueueEmitter.emitBatch(41) | Waiting on work from [ScoringQueue]:[0]\n2013-12-31 13:19:25,571-0500 | INFO [Thread-28] IsEndGame.isKeep(20) | END GAME [GAME [XOXOOXXXO]: player(O)\n history [         ,  X      , OX      , OX  X   , OX  X  O, OX  XX O, OXO XX O, OXO XXXO, OXOOXXXO,]]\n...\n ScoreUpdater.updateScore(43) | Updating [\n---------\n| ||O||X|\n---------\n|O|| ||X|\n---------\n|X||X||O|\n---------\n]=>[0]\n2013-12-31 13:19:25,574-0500 | DEBUG [Thread-28] ScoreUpdater.execute(27) | Got ( OXOOXXXO) => [0] for [X]\n2013-12-31 13:19:25,574-0500 | DEBUG [Thread-28] ScoreUpdater.updateScore(43) | Updating [\n---------\n| ||O||X|\n---------\n|O||O||X|\n---------\n|X||X||O|\n---------\n]=>[0]\n\n```", "```scala\npublic static void main(String[] args) throws Exception {\nfinal LocalCluster cluster = new LocalCluster();\nfinal Config conf = new Config();\n\nLocalDRPC client = new LocalDRPC();\nTridentTopology drpcTopology = new TridentTopology();\n\ndrpcTopology.newDRPCStream('drpc', client)\n                .each(new Fields('args'),\nnew ArgsFunction(),\nnew Fields('gamestate'))\n                .each(new Fields('gamestate'),\nnew GenerateBoards(),\nnew Fields('children'))\n                .each(new Fields('children'),\nnew ScoreFunction(),\nnew Fields('board', 'score', 'player'))\n                .groupBy(new Fields('gamestate'))\n                .aggregate(new Fields('board', 'score'),\nnew FindBestMove(), new Fields('bestMove'))\n                .project(new Fields('bestMove'));\n\ncluster.submitTopology('drpcTopology', conf,\n         drpcTopology.build());\n\nBoard board = new Board();\nboard.board[1][1] = 'O';\nboard.board[2][2] = 'X';\nboard.board[0][1] = 'O';\nboard.board[0][0] = 'X';\nLOG.info('Determining best move for O on:' + \n               board.toString());\nLOG.info('RECEIVED RESPONSE [' + \nclient.execute('drpc', board.toKey()) + ']');\n}\n```", "```scala\n    @Override\n    public void execute(TridentTuple tuple, \nTridentCollector collector) {\n        String args = tuple.getString(0);\n        Log.info('Executing DRPC w/ args = [' + args + ']');\n        Board board = new Board(args);\n        GameState gameState = \nnew GameState(board, new ArrayList<Board>(), 'X');\n        Log.info('Emitting [' + gameState + ']');\n\n        List<Object> values = new ArrayList<Object>();\n        values.add(gameState);\n        collector.emit(values);\n    }\n```", "```scala\n    public Board(String key) {\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                this.board[i][j] = '' + key.charAt(i*3+j);\n            }\n        }\n    }\n```", "```scala\npublic class FindBestMove extends BaseAggregator<BestMove> {\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public BestMove init(Object batchId, \nTridentCollector collector) {\n        Log.info('Batch Id = [' + batchId + ']');\n        return new BestMove();\n    }\n\n    @Override\n    public void aggregate(BestMove currentBestMove, \nTridentTuple tuple, TridentCollector collector) {  \n        Board board = (Board) tuple.get(0);\n        Integer score = tuple.getInteger(1);\n        if (score > currentBestMove.score){\n            currentBestMove.score = score;\n            currentBestMove.bestMove = board;\n        }\n    }\n\n    @Override\n    public void complete(BestMove bestMove, \nTridentCollector collector) {\n        collector.emit(new Values(bestMove));        \n    }\n\n}\n```", "```scala\npublic class BestMove {\n    public Board bestMove;\n    public Integer score = Integer.MIN_VALUE;\n\n    public String toString(){\n        return bestMove.toString() + '[' + score + ']';\n    }\n}\n```", "```scala\n2013-12-31 13:53:42,979-0500 | INFO [main] DrpcTopology.main(43) | Determining best move for O on:\n---------\n|X||O|| |\n---------\n| ||O|| |\n---------\n| || ||X|\n---------\n\n00:00  INFO: Executing DRPC w/ args = [XO  O   X]\n00:00  INFO: Emitting [GAME [XO  O   X]: player(X)\n history []]\n00:00  INFO: Batch Id = [storm.trident.spout.RichSpoutBatchId@1e8466d2]\n2013-12-31 13:53:44,092-0500 | INFO [main] DrpcTopology.main(44) | RECEIVED RESPONSE [[[\n---------\n|X||O|| |\n---------\n| ||O|| |\n---------\n| ||O||X|\n---------\n[10000]]]]\n\n```", "```scala\nbin/storm drpc\n```", "```scala\ndrpc.servers: \n- 'drpchost1 ' \n- 'drpchost2'\n\n```", "```scala\nDRPCClient client = new DRPCClient('drpchost1', 3772);\n```"]