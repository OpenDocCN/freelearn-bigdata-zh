["```scala\npublic class OutbreakDetectionTopology {\n\n    public static StormTopology buildTopology() {\n    TridentTopology topology = new TridentTopology();\n    DiagnosisEventSpout spout = new DiagnosisEventSpout();\n    Stream inputStream = topology.newStream(\"event\", spout);\n    inputStream\n    // Filter for critical events.\n.each(new Fields(\"event\"), new DiseaseFilter()))\n\n            // Locate the closest city\n         .each(new Fields(\"event\"),\n               new CityAssignment(), new Fields(\"city\"))\n\n         // Derive the hour segment\n         .each(new Fields(\"event\", \"city\"),\n               new HourAssignment(), new Fields(\"hour\",\n               \"cityDiseaseHour\"))\n\n         // Group occurrences in same city and hour\n         .groupBy(new Fields(\"cityDiseaseHour\"))\n\n         // Count occurrences and persist the results.\n         .persistentAggregate(new OutbreakTrendFactory(),\n                              new Count(),\n                              new Fields(\"count\"))\n\n         .newValuesStream()\n\n         // Detect an outbreak\n         .each(new Fields(\"cityDiseaseHour\", \"count\"),\n               new OutbreakDetector(), new Fields(\"alert\"))\n\n         // Dispatch the alert\n         .each(new Fields(\"alert\"),\n               new DispatchAlert(), new Fields());\n\n}\n}\n```", "```scala\npublic interface ITridentSpout<T> extends Serializable {\n\n   BatchCoordinator<T> getCoordinator(String txStateId,\n                              Map conf, TopologyContext context);\n   Emitter<T> getEmitter(String txStateId, Map conf,\n                         TopologyContext context);\n\n   Map getComponentConfiguration();\n\n   Fields getOutputFields();\n}\n```", "```scala\npublic class DiagnosisEventSpout implements ITridentSpout<Long> {\n private static final long serialVersionUID = 1L;\n SpoutOutputCollector collector;\n BatchCoordinator<Long> coordinator = new DefaultCoordinator();\n Emitter<Long> emitter = new DiagnosisEventEmitter();\n\n @Override\n public BatchCoordinator<Long> getCoordinator(\n         String txStateId, Map conf, TopologyContext context) {\n     return coordinator;\n }\n\n @Override\n public Emitter<Long> getEmitter(String txStateId, Map conf,\n                                TopologyContext context) {\n     return emitter;\n }\n\n @Override\n public Map getComponentConfiguration() {\n     return null;\n }\n\n @Override\n public Fields getOutputFields() {\n     return new Fields(\"event\");\n }\n}\n```", "```scala\npublic interface BatchCoordinator<X> {\n   X initializeTransaction(long txid, X prevMetadata);\n   void success(long txid);\n   boolean isReady(long txid);\n   void close();\n}\n```", "```scala\npublic class DefaultCoordinator implements BatchCoordinator<Long>,\n                                              Serializable {\n   private static final long serialVersionUID = 1L;\nprivate static final Logger LOG = \n             LoggerFactory.getLogger(DefaultCoordinator.class);\n\n@Override\npublic boolean isReady(long txid) {\n   return true;\n}\n\n@Override\npublic void close() {\n}\n\n@Override\npublic Long initializeTransaction(long txid,\n                                  Long prevMetadata) {\n   LOG.info(\"Initializing Transaction [\" + txid + \"]\");\n   return null;\n   }\n\n@Override\npublic void success(long txid) {\n   LOG.info(\"Successful Transaction [\" + txid + \"]\");\n}\n}\n```", "```scala\npublic interface Emitter<X> {\nvoid emitBatch(TransactionAttempt tx, X coordinatorMeta,\n               TridentCollector collector);\nvoid close();\n}\n```", "```scala\npublic class DiagnosisEventEmitter implements Emitter<Long>, Serializable {\n\nprivate static final long serialVersionUID = 1L;\nAtomicInteger successfulTransactions = new AtomicInteger(0);\n\n@Override\npublic void emitBatch(TransactionAttempt tx, Long\n                coordinatorMeta, TridentCollector collector) {\n   for (int i = 0; i < 10000; i++) {\n       List<Object> events = new ArrayList<Object>();\n       double lat = \n             new Double(-30 + (int) (Math.random() * 75));\n       double lng = \n             new Double(-120 + (int) (Math.random() * 70));\n       long time = System.currentTimeMillis();\n       String diag = new Integer(320 + \n                       (int) (Math.random() * 7)).toString();\n       DiagnosisEvent event = \n                    new DiagnosisEvent(lat, lng, time, diag);\n       events.add(event);\n       collector.emit(events);\n   }\n}\n\n@Override\npublic void success(TransactionAttempt tx) {\n   successfulTransactions.incrementAndGet();\n}\n\n@Override\npublic void close() {\n}\n}\n```", "```scala\npublic class DiagnosisEvent implements Serializable {\n    private static final long serialVersionUID = 1L;\n    public double lat;\n    public double lng;\n    public long time;\n    public String diagnosisCode;\n\n    public DiagnosisEvent(double lat, double lng,\n                       long time, String diagnosisCode) {\n   super();\n   this.time = time;\n   this.lat = lat;\n   this.lng = lng;\n   this.diagnosisCode = diagnosisCode;\n    }\n}\n```", "```scala\npublic class Stream implements IAggregatableStream {\npublic Stream each(Fields inputFields, Filter filter) {\n...\n}\n\npublic IAggregatableStream each(Fields inputFields,\nFunction function,\nFields functionFields){\n   ...\n}\n\npublic GroupedStream groupBy(Fields fields) {\n   ...\n   }\n\npublic TridentState persistentAggregate(\nStateFactory stateFactory,\nCombinerAggregator agg, \nFields functionFields) {\n        ...\n}\n}\n```", "```scala\n   inputStream.each(new Fields(\"event\"), new DiseaseFilter())\n      .each(new Fields(\"event\"), new CityAssignment(),\n               new Fields(\"city\"))\n\n      .each(new Fields(\"event\", \"city\"),\n               new HourAssignment(),\n             new Fields(\"hour\", \"cityDiseaseHour\"))\n\n      .groupBy(new Fields(\"cityDiseaseHour\"))\n\n      .persistentAggregate(new OutbreakTrendFactory(),\n              new Count(), new Fields(\"count\")).newValuesStream()\n\n      .each(new Fields(\"cityDiseaseHour\", \"count\"),\n               new OutbreakDetector(), new Fields(\"alert\"))\n\n      .each(new Fields(\"alert\"), new DispatchAlert(),\n               new Fields());\n```", "```scala\npublic interface Filter extends EachOperation {\n    boolean isKeep(TridentTuple tuple);\n}\n```", "```scala\npublic class DiseaseFilter extends BaseFilter {\nprivate static final long serialVersionUID = 1L;\nprivate static final Logger LOG = \nLoggerFactory.getLogger(DiseaseFilter.class);\n\n@Override\npublic boolean isKeep(TridentTuple tuple) {\n   DiagnosisEvent diagnosis = (DiagnosisEvent) tuple.getValue(0);\n   Integer code = Integer.parseInt(diagnosis.diagnosisCode);\n   if (code.intValue() <= 322) {\n       LOG.debug(\"Emitting disease [\" + \ndiagnosis.diagnosisCode + \"]\");\n       return true;\n   } else {\n       LOG.debug(\"Filtering disease [\" + \ndiagnosis.diagnosisCode + \"]\");\n       return false;\n   }\n}\n}\n```", "```scala\n   inputStream.each(new Fields(\"event\"), new DiseaseFilter())\n```", "```scala\npublic interface Function extends EachOperation {\nvoid execute(TridentTuple tuple, TridentCollector collector);\n}\n```", "```scala\npublic class CityAssignment extends BaseFunction {\nprivate static final long serialVersionUID = 1L;\nprivate static final Logger LOG = LoggerFactory.getLogger(CityAssignment.class);\n\nprivate static Map<String, double[]> CITIES = \n                        new HashMap<String, double[]>();\n\n    { // Initialize the cities we care about.\n        double[] phl = { 39.875365, -75.249524 };\n        CITIES.put(\"PHL\", phl);\n        double[] nyc = { 40.71448, -74.00598 };\n        CITIES.put(\"NYC\", nyc);\n        double[] sf = { -31.4250142, -62.0841809   };\n        CITIES.put(\"SF\", sf);\n        double[] la = { -34.05374, -118.24307 };\n        CITIES.put(\"LA\", la);\n    }\n\n    @Override\n    public void execute(TridentTuple tuple, \nTridentCollector collector) {\n       DiagnosisEvent diagnosis = \n                           (DiagnosisEvent) tuple.getValue(0);\n       double leastDistance = Double.MAX_VALUE;\n       String closestCity = \"NONE\";\n\n       // Find the closest city.\n       for (Entry<String, double[]> city : CITIES.entrySet()) {\n          double R = 6371; // km\n          double x = (city.getValue()[0] - diagnosis.lng) * \n             Math.cos((city.getValue()[0] + diagnosis.lng) / 2);\n          double y = (city.getValue()[1] - diagnosis.lat);\n          double d = Math.sqrt(x * x + y * y) * R;\n          if (d < leastDistance) {\n          leastDistance = d;\n          closestCity = city.getKey();\n          }\n      }\n\n      // Emit the value.\n      List<Object> values = new ArrayList<Object>();\n      Values.add(closestCity);\n      LOG.debug(\"Closest city to lat=[\" + diagnosis.lat + \n                \"], lng=[\" + diagnosis.lng + \"] == [\"\n                + closestCity + \"], d=[\" + leastDistance + \"]\");\n      collector.emit(values);\n    }\n}\n```", "```scala\npublic class HourAssignment extends BaseFunction {\nprivate static final long serialVersionUID = 1L;\nprivate static final Logger LOG =    \n               LoggerFactory.getLogger(HourAssignment.class);\n\n@Override\npublic void execute(TridentTuple tuple,\n                   TridentCollector collector) {\n   DiagnosisEvent diagnosis = (DiagnosisEvent) tuple.getValue(0);\n   String city = (String) tuple.getValue(1);\n\n   long timestamp = diagnosis.time;\n   long hourSinceEpoch = timestamp / 1000 / 60 / 60;\n\n   LOG.debug(\"Key =  [\" + city + \":\" + hourSinceEpoch + \"]\");\n   String key = city + \":\" + diagnosis.diagnosisCode + \":\" + \n\n                hourSinceEpoch;\n\n   List<Object> values = new ArrayList<Object>();\n   values.add(hourSinceEpoch);\n   values.add(key);\n   collector.emit(values);\n}\n}\n```", "```scala\npublic class OutbreakDetector extends BaseFunction {\n    private static final long serialVersionUID = 1L;\n    public static final int THRESHOLD = 10000;\n\n    @Override\n    public void execute(TridentTuple tuple,\n                         TridentCollector collector) {\n   String key = (String) tuple.getValue(0);\n   Long count = (Long) tuple.getValue(1);\n\n   if (count > THRESHOLD) {\n       List<Object> values = new ArrayList<Object>();\n       values.add(\"Outbreak detected for [\" + key + \"]!\");\n       collector.emit(values);\n   }\n}\n}\n```", "```scala\npublic class DispatchAlert extends BaseFunction {\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void execute(TridentTuple tuple, \n                     TridentCollector collector) {\n   String alert = (String) tuple.getValue(0);\n   Log.error(\"ALERT RECEIVED [\" + alert + \"]\");\n   Log.error(\"Dispatch the national guard!\");\n   System.exit(0);\n   }\n}\n```", "```scala\npublic interface CombinerAggregator {\n   T init (TridentTuple tuple);\n   T combine(T val1, T val2);\n   T zero();\n}\n```", "```scala\npublic interface ReducerAggregator<T> extends Serializable {\n    T init();\n    T reduce(T curr, TridentTuple tuple);\n}\n```", "```scala\npublic interface Aggregator<T> extends Operation {\n    T init(Object batchId, TridentCollector collector);\n    void aggregate(T val, TridentTuple tuple,\nTridentCollector collector);\n void complete(T val, TridentCollector collector);\n}\n```", "```scala\npublic class Count implements CombinerAggregator<Long> {\n    @Override\n    public Long init(TridentTuple tuple) {\n        return 1L;\n    }\n\n    @Override\n    public Long combine(Long val1, Long val2) {\n        return val1 + val2;\n    }\n\n    @Override\n    public Long zero() {\n        return 0L;\n    }\n}\n```", "```scala\n.groupBy(new Fields(\"cityDiseaseHour\"))\n.persistentAggregate(new OutbreakTrendFactory(), \n   new Count(), new Fields(\"count\")).newValuesStream()\n```", "```scala\npublic interface State {\n   void beginCommit(Long transactionId); \n   void commit(Long transactionId);\n}\n```", "```scala\npublic class Stream implements IAggregatableStream {\n    ...\n    public Stream stateQuery(TridentState state, Fields inputFields,\n            QueryFunction function, Fields functionFields) {\n   ...\n }\n\npublic TridentState partitionPersist(StateFactory stateFactory,\nFields inputFields, StateUpdater updater,\nFields functionFields) {\n   ...\n}\n\npublic TridentState partitionPersist(StateSpec stateSpec,\nFields inputFields, StateUpdater updater,\nFields functionFields) {\n   ...\n}\n\npublic TridentState partitionPersist(StateFactory stateFactory,\nFields inputFields, StateUpdater updater) {\n   ...\n   }\n\npublic TridentState partitionPersist(StateSpec stateSpec,\nFields inputFields, StateUpdater updater) {\n    ...\n}\n...\n}\n```", "```scala\npublic class GroupedStream implements IAggregatableStream,\nGlobalAggregationScheme<GroupedStream> {\n...\n   public TridentState persistentAggregate(\nStateFactory stateFactory, CombinerAggregator agg,\nFields functionFields) {\n...\n}\n\npublic TridentState persistentAggregate(StateSpec spec,\nCombinerAggregator agg, Fields functionFields) {\n...\n}\n\npublic TridentState persistentAggregate(\nStateFactory stateFactory, Fields inputFields,\nCombinerAggregator agg, Fields functionFields) {\n...\n}\n\npublic TridentState persistentAggregate(StateSpec spec,\nFields inputFields, CombinerAggregator agg,\nFields functionFields) {\n...\n}\n\npublic TridentState persistentAggregate(\nStateFactory stateFactory, Fields inputFields,\nReducerAggregator agg, Fields functionFields) {\n...\n}\n\npublic TridentState persistentAggregate(StateSpec spec, Fields inputFields, ReducerAggregator agg, Fields functionFields) {\n...\n}\n\npublic Stream stateQuery(TridentState state, Fields inputFields,\nQueryFunction function, Fields functionFields) {\n...\n}    \n\npublic TridentState persistentAggregate(\nStateFactory stateFactory, ReducerAggregator agg,\nFields functionFields) {\n...\n}\n\npublic TridentState persistentAggregate(StateSpec spec,\nReducerAggregator agg, Fields functionFields) {\n...\n}    \n\npublic Stream stateQuery(TridentState state,\n   QueryFunction function, Fields functionFields) {\n...\n}\n}\n```", "```scala\n persistentAggregate(new OutbreakTrendFactory(), \n   new Count(), new Fields(\"count\")).newValuesStream()\n```", "```scala\npublic class OutbreakTrendFactory implements StateFactory {\nprivate static final long serialVersionUID = 1L;\n\n@Override\npublic State makeState(Map conf, IMetricsContext metrics,\nint partitionIndex, int numPartitions) {\n   return new OutbreakTrendState(new OutbreakTrendBackingMap());\n}\n}\n```", "```scala\npublic class OutbreakTrendState extends NonTransactionalMap<Long> {\nprotected OutbreakTrendState(\nOutbreakTrendBackingMap outbreakBackingMap) {\n   super(outbreakBackingMap);\n}\n}\n```", "```scala\npublic class OutbreakTrendBackingMap implements IBackingMap<Long> {\n    private static final Logger LOG = \nLoggerFactory.getLogger(OutbreakTrendBackingMap.class);\n Map<String, Long> storage = \nnew ConcurrentHashMap<String, Long>();\n\n @Override\n public List<Long> multiGet(List<List<Object>> keys) {\n    List<Long> values = new ArrayList<Long>();\n    for (List<Object> key : keys) {\n        Long value = storage.get(key.get(0));\n        if (value==null){\n            values.add(new Long(0));\n        } else {\n            values.add(value);\n        }\n    }\n    return values;\n}\n\n@Override\npublic void multiPut(List<List<Object>> keys, List<Long> vals) {\n    for (int i=0; i < keys.size(); i++) {\n        LOG.info(\"Persisting [\" + keys.get(i).get(0) + \"] ==> [\" \n+ vals.get(i) + \"]\");\n        storage.put((String) keys.get(i).get(0), vals.get(i));\n    }\n}\n}\n```", "```scala\npublic static void main(String[] args) throws Exception {\n    Config conf = new Config();\n    LocalCluster cluster = new LocalCluster();\n    cluster.submitTopology(\"cdc\", conf, buildTopology());\n    Thread.sleep(200000);\n    cluster.shutdown();\n}\n```", "```scala\nINFO [Thread-18] DefaultCoordinator.success(31) | Successful Transaction [8]\nINFO [Thread-18] DefaultCoordinator.initializeTransaction(25) | Initializing Transaction [9]\n...\nINFO [Thread-24] OutbreakTrendBackingMap.multiPut(34) | Persisting [SF:320:378951] ==> [10306]\nINFO [Thread-24] OutbreakTrendBackingMap.multiPut(34) | Persisting [PHL:320:378951] ==> [893]\nINFO [Thread-24] OutbreakTrendBackingMap.multiPut(34) | Persisting [NYC:322:378951] ==> [1639]\nINFO [Thread-24] OutbreakTrendBackingMap.multiPut(34) | Persisting [SF:322:378951] ==> [10254]\nINFO [Thread-24] OutbreakTrendBackingMap.multiPut(34) | Persisting [SF:321:378951] ==> [10386]\n...\n00:04 ERROR: ALERT RECEIVED [Outbreak detected for [SF:320:378951]!]\n00:04 ERROR: Dispatch the National Guard!\n\n```"]