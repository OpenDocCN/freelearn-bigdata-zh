["```scala\n23:25:1256=BANZAI6=011=135215791235714=017=520=031=032=037=538=1000039=054=155=SPY150=2151=010=2528=FIX.4.19=10435=F34=649=BANZAI52=20121105-\n```", "```scala\npublic class FinancialAnalyticsTopology {\n\n    public static StormTopology buildTopology() {\n    TridentTopology topology = new TridentTopology();\n    FixEventSpout spout = new FixEventSpout();\n    Stream inputStream = \ntopology.newStream(\"message\", spout);\n    inputStream.each(new Fields(\"message\"),\nnew MessageTypeFilter())\n        .partitionPersist(new DruidStateFactory(),\nnew Fields(\"message\"), new DruidStateUpdater());\n    return topology.build();\n    }\n\n}\n```", "```scala\npackage com.packtpub.storm.trident.spout;\n\n@SuppressWarnings(\"rawtypes\")\npublic class FixEventSpout implements ITridentSpout<Long> {\n    private static final long serialVersionUID = 1L;\n    SpoutOutputCollector collector;\n    BatchCoordinator<Long> coordinator = new DefaultCoordinator();\n    Emitter<Long> emitter = new FixEventEmitter();\n    ...\n    @Override\n    public Fields getOutputFields() {\n        return new Fields(\"message\");\n    }\n}\n```", "```scala\npackage com.packtpub.storm.trident.spout;\n\npublic class FixEventEmitter implements Emitter<Long>,\nSerializable {\n    private static final long serialVersionUID = 1L;\n    public static AtomicInteger successfulTransactions = \nnew AtomicInteger(0);\n    public static AtomicInteger uids = new AtomicInteger(0);\n\n    @SuppressWarnings(\"rawtypes\")\n    @Override\n    public void emitBatch(TransactionAttempt tx,\n    Long coordinatorMeta, TridentCollector collector) {\n    InputStream inputStream = null;\n    File file = new File(\"fix_data.txt\");\n    try {\n        inputStream = \nnew BufferedInputStream(new FileInputStream(file));\n        SimpleFixParser parser = new SimpleFixParser(inputStream);\n        SimpleFixMessage msg = null;\n        do {\n        msg = parser.readFixMessage();\n        if (null != msg) {\n            FixMessageDto dto = new FixMessageDto();\n            for (TagValue tagValue : msg.fields()) {\n                if (tagValue.tag().equals(\"6\")) { // AvgPx\n                    // dto.price = \n//Double.valueOf((String) tagValue.value());\n                    dto.price = new Double((int) (Math.random() * 100));\n                } else if (tagValue.tag().equals(\"35\")) {\n                    dto.msgType = (String)tagValue.value();\n                } else if (tagValue.tag().equals(\"55\")) {\n                   dto.symbol = (String) tagValue.value();\n                } else if (tagValue.tag().equals(\"11\")){\n                   // dto.uid = (String) tagValue.value();\n                   dto.uid = Integer.toString(uids.incrementAndGet());\n                }\n            }\n            new ObjectOutputStream(\n            new ByteArrayOutputStream()).writeObject(dto);\n                List<Object> message = new ArrayList<Object>();\n                message.add(dto);\n                collector.emit(message);\n        }\n    } while (msg != null);\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    } finally {\n        IoUtils.closeSilently(inputStream);\n    }\n    }\n\n    @Override\n    public void success(TransactionAttempt tx) {\n        successfulTransactions.incrementAndGet();\n    }\n\n    @Override\n    public void close() {\n    }\n}\n```", "```scala\npackage com.packtpub.storm.trident.operator;\n\npublic class MessageTypeFilter extends BaseFilter {\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public boolean isKeep(TridentTuple tuple) {\n        FixMessageDto message = (FixMessageDto) tuple.getValue(0);\n    if (message.msgType.equals(\"8\")) {\n        return true;\n    }\n    return false;\n    }\n}\n```", "```scala\nnew ObjectOutputStream(\nnew ByteArrayOutputStream()).\nwriteObject(YOUR_OBJECT);\n```", "```scala\npublic class DruidStateFactory implements StateFactory {\n    private static final long serialVersionUID = 1L;\n    private static final Logger LOG = \nLoggerFactory.getLogger(DruidStateFactory.class);\n    private static RealtimeNode rn = null;\n\n    private static synchronized void startRealtime() {\n    if (rn == null) {\n        final Lifecycle lifecycle = new Lifecycle();\n        rn = RealtimeNode.builder().build();\n        lifecycle.addManagedInstance(rn);\n        rn.registerJacksonSubtype(\n        new NamedType(StormFirehoseFactory.class, \"storm\"));\n\n        try {\n            lifecycle.start();\n        } catch (Throwable t) {\n\n        }\n    }\n    }\n\n    @Override\n    public State makeState(Map conf, IMetricsContext metrics,\n        int partitionIndex, int numPartitions) {\n            DruidStateFactory.startRealtime();\n            return new DruidState(partitionIndex);\n    }\n}\n```", "```scala\npublic class DruidState implements State {\nprivate static final Logger LOG = \nLoggerFactory.getLogger(DruidState.class);\nprivate Vector<FixMessageDto> messages = \nnew Vector<FixMessageDto>();\n    private int partitionIndex;\n\npublic DruidState(int partitionIndex){\n    this.partitionIndex = partitionIndex;\n}\n\n@Override\n    public void beginCommit(Long batchId) {\n}\n\n@Override\npublic void commit(Long batchId) {\n    String partitionId = batchId.toString() + \"-\" + partitionIndex;\n    LOG.info(\"Committing partition [\" + \n        partitionIndex + \"] of batch [\" + batchId + \"]\");\n    try {\n        if (StormFirehose.STATUS.isCompleted(partitionId)) {\n        LOG.warn(\"Encountered completed partition [\" \n            + partitionIndex + \"] of batch [\" + batchId \n                + \"]\");\n        return;\n    } else if (StormFirehose.STATUS.isInLimbo(partitionId)) {\n        LOG.warn(\"Encountered limbo partition [\" + partitionIndex \n                 + \"] of batch [\" + batchId + \n                 \"] : NOTIFY THE AUTHORITIES!\");\n        return;\n    } else if (StormFirehose.STATUS.isInProgress(partitionId)) {\n              LOG.warn(\"Encountered in-progress partition [\\\" + \n              partitionIndex + \\\"] of batch [\" + batchId + \n              \"] : NOTIFY THE AUTHORITIES!\");\n        return;\n    }\n    StormFirehose.STATUS.putInProgress(partitionId);\n    StormFirehoseFactory.getFirehose()\n        .sendMessages(partitionId, messages);\n    } catch (Exception e) {\n            LOG.error(\"Could not start firehose for [\" + \n                      partitionIndex + \"] of batch [\" + \n                      batchId + \"]\", e);\n    }\n    }\n\npublic void aggregateMessage(FixMessageDto message) {\n    messages.add(message);\n}\n}\n```", "```scala\npublic class DruidStateUpdater implements StateUpdater<DruidState> {\n...\n@Override\npublic void updateState(DruidState state, \nList<TridentTuple> tuples, TridentCollector collector) {\nfor (TridentTuple tuple : tuples) {\n   \t   FixMessageDto message = (FixMessageDto) tuple.getValue(0);\n      state.aggregateMessage(message);\n   }\n}\n}\n```", "```scala\n[{\n    \"schema\": {\n        \"dataSource\": \"stockinfo\",\n        \"aggregators\": [\n            { \"type\": \"count\", \"name\": \"orders\"},\n            { \"type\": \"doubleSum\", \"fieldName\": \"price\", \"name\":\"totalPrice\" }\n        ],\n        \"indexGranularity\": \"minute\",\n        \"shardSpec\": {\"type\": \"none\"}\n    },\n\n    \"config\": {\n        \"maxRowsInMemory\": 50000,\n        \"intermediatePersistPeriod\": \"PT30s\"\n    },\n\n    \"firehose\": {\n        \"type\": \"storm\",\n        \"sleepUsec\": 100000,\n        \"maxGeneratedRows\": 5000000,\n        \"seed\": 0,\n        \"nTokens\": 255,\n        \"nPerSleep\": 3\n    },\n\n    \"plumber\": {\n        \"type\": \"realtime\",\n        \"windowPeriod\": \"PT30s\",\n        \"segmentGranularity\": \"minute\",\n        \"basePersistDirectory\": \"/tmp/example/rand_realtime/basePersist\"\n    }\n}]\n```", "```scala\n@JsonTypeName(\"storm\")\npublic class StormFirehoseFactory implements FirehoseFactory {\n    private static final StormFirehose FIREHOSE = \n    new StormFirehose();\n    @JsonCreator\n    public StormFirehoseFactory() {\n    }\n\n    @Override\n    public Firehose connect() throws IOException {\n        return FIREHOSE;\n    }\n\n    public static StormFirehose getFirehose(){\n        return FIREHOSE;\n    }\n}\n```", "```scala\npublic synchronized void sendMessages(String partitionId, \n                     List<FixMessageDto> messages) {\n    BLOCKING_QUEUE = \n    new ArrayBlockingQueue<FixMessageDto>(messages.size(), \n    false, messages);\n    TRANSACTION_ID = partitionId;\n    LOG.info(\"Beginning commit to Druid. [\" + messages.size() + \n    \"] messages, unlocking [START]\");\n    synchronized (START) {\n        START.notify();\n    }\n    try {\n        synchronized (FINISHED) {\n        FINISHED.wait();\n        }\n    } catch (InterruptedException e) {\n        LOG.error(\"Commit to Druid interrupted.\");\n    }\n    LOG.info(\"Returning control to Storm.\");\n}\n```", "```scala\n    @Override\n    public InputRow nextRow() {\n        final Map<String, Object> theMap = \n        Maps.newTreeMap(String.CASE_INSENSITIVE_ORDER);\n        try {\n        FixMessageDto message = null;\n        message = BLOCKING_QUEUE.poll();\n\n        if (message != null) {\n        LOG.info(\"[\" + message.symbol + \"] @ [\" +\n         message.price + \"]\");\n        theMap.put(\"symbol\", message.symbol);\n        theMap.put(\"price\", message.price);\n        }\n\n        if (BLOCKING_QUEUE.isEmpty()) {\n        STATUS.putInLimbo(TRANSACTION_ID);\n        LIMBO_TRANSACTIONS.add(TRANSACTION_ID);\n        LOG.info(\"Batch is fully consumed by Druid. \" \n        + \"Unlocking [FINISH]\");\n        synchronized (FINISHED) {\n            FINISHED.notify();\n\n        }\n        }\n    } catch (Exception e) {\n        LOG.error(\"Error occurred in nextRow.\", e);\n        System.exit(-1);\n    }\n    final LinkedList<String> dimensions = \n    new LinkedList<String>();\n    dimensions.add(\"symbol\");\n    dimensions.add(\"price\");\n    return new MapBasedInputRow(System.currentTimeMillis(), \n                                dimensions, theMap);\n    }\n```", "```scala\n@Override\npublic boolean hasMore() {\n    if (BLOCKING_QUEUE != null && !BLOCKING_QUEUE.isEmpty())\n        return true;\n    try {\n        synchronized (START) {\n        START.wait();\n        }\n    } catch (InterruptedException e) {\n        LOG.error(\"hasMore() blocking interrupted!\");\n    }\n    return true;\n}\n```", "```scala\n    @Override\n    public Runnable commit() {\n\tList<String> limboTransactions = new ArrayList<String>();\n\tLIMBO_TRANSACTIONS.drainTo(limboTransactions);\n\treturn new StormCommitRunnable(limboTransactions);\n    }\n```", "```scala\npublic class StormCommitRunnable implements Runnable {\n    private List<String> partitionIds = null;\n\n    public StormCommitRunnable(List<String> partitionIds){\n        this.partitionIds = partitionIds;\n    }\n\n    @Override\n    public void run() {\n    try {\n        StormFirehose.STATUS.complete(partitionIds);\n    } catch (Exception e) {\n        Log.error(\"Could not complete transactions.\", e);\n    }\n}\n}\n```", "```scala\npublic class DruidBatchStatus {\n    private static final Logger LOG = \nLoggerFactory.getLogger(DruidBatchStatus.class);\n    final String COMPLETED_PATH = \"completed\";\n    final String LIMBO_PATH = \"limbo\";\n    final String CURRENT_PATH = \"current\";\n    private CuratorFramework curatorFramework;\n\n    public DruidBatchStatus() {\n    try {\ncuratorFramework = \n    CuratorFrameworkFactory.builder()\n    .namespace(\"stormdruid\")\n    .connectString(\"localhost:2181\")\n    .retryPolicy(new RetryNTimes(1, 1000))\n    .connectionTimeoutMs(5000)\n            .build();\n        curatorFramework.start();\n\n        if (curatorFramework.checkExists()\n    .forPath(COMPLETED_PATH) == null) {\n        curatorFramework.create().forPath(COMPLETED_PATH);\n        }\n\n    }catch (Exception e) {\n        LOG.error(\"Could not establish connection to Zookeeper\", \n                  e);\n    }\n    }\n\n    public boolean isInLimbo(String paritionId) throws Exception {\n        return (curatorFramework.checkExists().forPath(LIMBO_PATH + \"/\" + paritionId) != null);\n    }\n\n    public void putInLimbo(Long paritionId) throws Exception {\n    curatorFramework.inTransaction().\n        delete().forPath(CURRENT_PATH + \"/\" + paritionId)\n        .and().create().forPath(LIMBO_PATH + \"/\" + \n                                paritionId).and().commit();\n    }\n}\n```", "```scala\n2014-02-16 09:47:15,479-0500 | INFO [Thread-18] DefaultCoordinator.initializeTransaction(24) | Initializing Transaction [1615]\n2014-02-16 09:47:15,482-0500 | INFO [Thread-22] DruidState.commit(28) | Committing partition [0] of batch [1615]\n2014-02-16 09:47:15,484-0500 | INFO [Thread-22] StormFirehose.sendMessages(82) | Beginning commit to Druid. [7996] messages, unlocking [START]\n2014-02-16 09:47:15,511-0500 | INFO [chief-stockinfo] StormFirehose.nextRow(58) | Batch is fully consumed by Druid. Unlocking [FINISH]\n2014-02-16 09:47:15,511-0500 | INFO [Thread-22] StormFirehose.sendMessages(93) | Returning control to Storm.\n2014-02-16 09:47:15,513-0500 | INFO [Thread-18] DefaultCoordinator.success(30) | Successful Transaction [1615] \n```", "```scala\n[zk: localhost:2181(CONNECTED) 50] ls /stormdruid/current\n[501-0]\n[zk: localhost:2181(CONNECTED) 51] ls /stormdruid/limbo\n[486-0, 417-0, 421-0, 418-0, 487-0, 485-0, 484-0, 452-0, ...\n[zk: localhost:2181(CONNECTED) 82] ls /stormdruid/completed\n[zk: localhost:2181(CONNECTED) 52] ls /stormdruid/completed\n[59-0, 321-0, 296-0, 357-0, 358-0, 220-0, 355-0,\n```", "```scala\nzk: localhost:2181(CONNECTED) 83] rmr /stormdruid\n```", "```scala\nmysql> select * from prod_segments;\n```", "```scala\ncurl -sX POST \"http://localhost:7070/druid/v2/?pretty=true\" -H 'content-type: application/json'  -d @storm_query\n\n```", "```scala\n{\n    \"queryType\": \"groupBy\",\n    \"dataSource\": \"stockinfo\",\n    \"granularity\": \"minute\",\n    \"dimensions\": [\"symbol\"],\n    \"aggregations\":[\n        { \"type\": \"longSum\", \"fieldName\": \"orders\",\n         \"name\": \"cumulativeCount\"},\n        { \"type\": \"doubleSum\", \"fieldName\": \"totalPrice\",\n         \"name\": \"cumulativePrice\" }\n    ],\n    \"postAggregations\":[\n    {  \"type\":\"arithmetic\",\n        \"name\":\"avg_price\",\n        \"fn\":\"/\",\n        \"fields\":[ {\"type\":\"fieldAccess\",\"name\":\"avgprice\",\n        \"fieldName\":\"cumulativePrice\"},\n                   {\"type\":\"fieldAccess\",\"name\":\"numrows\",\n        \"fieldName\":\"cumulativeCount\"}]}\n    ],\n    \"intervals\":[\"2012-10-01T00:00/2020-01-01T00\"]\n}\n```", "```scala\n\"aggregators\": [\n{ \"type\": \"count\", \"name\": \"orders\"},\n   { \"type\": \"doubleSum\", \"fieldName\": \"price\",\n\"name\": \"totalPrice\" }\n],\n```", "```scala\n[ {\n  \"version\" : \"v1\",\n  \"timestamp\" : \"2013-05-15T22:31:00.000Z\",\n  \"event\" : {\n    \"cumulativePrice\" : 3464069.0,\n    \"symbol\" : \"MSFT\",\n    \"cumulativeCount\" : 69114,\n    \"avg_price\" : 50.12108979367422\n  }\n}, {\n  \"version\" : \"v1\",\n  \"timestamp\" : \"2013-05-15T22:31:00.000Z\",\n  \"event\" : {\n    \"cumulativePrice\" : 3515855.0,\n    \"symbol\" : \"ORCL\",\n    \"cumulativeCount\" : 68961,\n    \"avg_price\" : 50.98323690201708\n  }\n...\n {\n  \"version\" : \"v1\",\n  \"timestamp\" : \"2013-05-15T22:32:00.000Z\",\n  \"event\" : {\n    \"cumulativePrice\" : 1347494.0,\n    \"symbol\" : \"ORCL\",\n    \"cumulativeCount\" : 26696,\n    \"avg_price\" : 50.47550194785736\n  }\n}, {\n  \"version\" : \"v1\",\n  \"timestamp\" : \"2013-05-15T22:32:00.000Z\",\n  \"event\" : {\n    \"cumulativePrice\" : 707317.0,\n    \"symbol\" : \"SPY\",\n    \"cumulativeCount\" : 13453,\n    \"avg_price\" : 52.576897346316805\n  }\n} ]\n```"]