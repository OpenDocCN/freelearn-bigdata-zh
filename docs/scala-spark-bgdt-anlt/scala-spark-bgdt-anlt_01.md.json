["```scala\n$ java -version \n\n```", "```scala\n $ sudo apt-get install default-jre \n\n```", "```scala\n$ sudo apt-get install python-software-properties\n$ sudo apt-get update\n$ sudo add-apt-repository ppa:webupd8team/java\n$ sudo apt-get update \n\n```", "```scala\n$ sudo apt-get install oracle-java8-installer\n\n```", "```scala\n$ echo \"export JAVA_HOME=/usr/lib/jvm/java-8-oracle\" >> ~/.bashrc  \n$ echo \"export PATH=$PATH:$JAVA_HOME/bin\" >> ~/.bashrc\n$ source ~/.bashrc \n\n```", "```scala\n$ echo $JAVA_HOME\n\n```", "```scala\n /usr/lib/jvm/java-8-oracle\n\n```", "```scala\n$ java -version\n\n```", "```scala\njava version \"1.8.0_121\"\nJava(TM) SE Runtime Environment (build 1.8.0_121-b13)\nJava HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode)\n\n```", "```scala\n$ /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n\n```", "```scala\n$ tar xvf scala-2.11.8.tgz\n\n```", "```scala\n$ sudo mv scala-2.11.8 /usr/local/share\n\n```", "```scala\n$ echo \"export SCALA_HOME=/usr/local/share/scala-2.11.8\" >> ~/.bash_profile\n$ echo \"export PATH=$PATH: $SCALA_HOME/bin\" >> ~/.bash_profile \n\n```", "```scala\n$ scala -version\n\n```", "```scala\nScala code runner version 2.11.8 -- Copyright 2002-2016, LAMP/EPFL\n\n```", "```scala\n$ cd Downloads/\n$ wget https://downloads.lightbend.com/scala/2.11.8/scala-2.11.8.tgz\n\n```", "```scala\n$ tar -xvzf scala-2.11.8.tgz\n\n```", "```scala\n $ sudo mv scala-2.11.8 /usr/local/share/\n\n```", "```scala\n$ cd ~\n\n```", "```scala\n$ echo \"export SCALA_HOME=/usr/local/share/scala-2.11.8\" >> ~/.bashrc \n$ echo \"export PATH=$PATH:$SCALA_HOME/bin\" >> ~/.bashrc\n\n```", "```scala\n$ source ~/.bashrc\n\n```", "```scala\n$ scala -version\n\n```", "```scala\nScala code runner version 2.11.8 -- Copyright 2002-2016, LAMP/EPFL\n\n```", "```scala\n$ sudo apt-get install scala\n\n```", "```scala\n i:Int = \"hello\"\n\n```", "```scala\n<console>:11: error: type mismatch;\n  found   : String(\"hello\")\n  required: Int\n        val i:Int = \"hello\"\n                    ^\n\n```", "```scala\nscala> \"abc\" map (x => (x + 1).toChar) \nres0: String = bcd\n\n```", "```scala\n\"abc\" map (x => (x + 1)) \nres1: scala.collection.immutable.IndexedSeq[Int] = Vector(98, 99, 100)\n\n```", "```scala\nscala> val x = \"hello\"\nx: java.lang.String = hello\nscala> x.re<tab>\nreduce             reduceRight         replaceAll            reverse\nreduceLeft         reduceRightOption   replaceAllLiterally   reverseIterator\nreduceLeftOption   regionMatches       replaceFirst          reverseMap\nreduceOption       replace             repr\nscala> \n\n```", "```scala\nscala> val x = new AnyRef{def helloWord = \"Hello, world!\"}\nx: AnyRef{def helloWord: String} = $anon$1@58065f0c\n scala> x.helloWord\n def helloWord: String\n scala> x.helloWord\n warning: there was one feature warning; re-run with -feature for details\n res0: String = Hello, world!\n\n```", "```scala\ndef sum(vector: List[Int]): Int = {\n  // Nested helper method (won't be accessed from outside this function\n  def helper(acc: Int, remaining: List[Int]): Int = remaining match {\n    case Nil => acc\n    case _   => helper(acc + remaining.head, remaining.tail)\n  }\n  // Call the nested method\n  helper(0, vector)\n}\n\n```", "```scala\n// Import everything from the package math \nimport math._\n\n```", "```scala\n// Import math.sin and math.cos\nimport math.{sin, cos}\n\n```", "```scala\nimport static java.lang.Math.sin;\nimport static java.lang.Math.cos;\n\n```", "```scala\n// Import Scala.collection.mutable.Map as MutableMap \nimport Scala.collection.mutable.{Map => MutableMap}\n\n```", "```scala\n// Import everything from math, but hide cos \nimport math.{cos => _, _}\n\n```", "```scala\nval x = 45\nval y = 75\n\n```", "```scala\nval add1 = x.+(y)\n\n```", "```scala\nval add2 = x + y\n\n```", "```scala\nval my_result = List(3, 6, 15, 34, 76) contains 5\n\n```", "```scala\nval my_list = List(3, 6, 15, 34, 76)\n\n```", "```scala\nval my_result = 5 +: my_list\n\n```", "```scala\nscala> val my_list = 5 +: List(3, 6, 15, 34, 76)\n my_list: List[Int] = List(5, 3, 6, 15, 34, 76)\nscala> val my_result2 = 5+:my_list\n my_result2: List[Int] = List(5, 5, 3, 6, 15, 34, 76)\nscala> println(my_result2)\n List(5, 5, 3, 6, 15, 34, 76)\nscala>\n\n```", "```scala\ndef sum(x: Int)(y: Int) = x + y     \n\n```", "```scala\ndef sum(x: Int, y: Int) = x + y\n\n```", "```scala\ndef sum2 = sum(2) _\n\n```", "```scala\nval result = add2(5)\n\n```", "```scala\ndef main_method(xs: List[Int]): Int = {\n  // This is the nested helper/auxiliary method\n  def auxiliary_method(accu: Int, rest: List[Int]): Int = rest match {\n    case Nil => accu\n    case _   => auxiliary_method(accu + rest.head, rest.tail)\n  }\n}\n\n```", "```scala\nauxiliary_method(0, xs)\n\n```", "```scala\ndef main_method(xs: List[Int]): Int = {\n  // This is the nested helper/auxiliary method\n  def auxiliary_method(accu: Int, rest: List[Int]): Int = rest match {\n    case Nil => accu\n    case _   => auxiliary_method(accu + rest.head, rest.tail)\n  }\n   auxiliary_method(0, xs)\n}\n\n```", "```scala\nclass Hello(name: String) {\n  // Statement executed as part of the constructor\n  println(\"New instance with name: \" + name)\n  // Method which accesses the constructor argument\n  def sayHello = println(\"Hello, \" + name + \"!\")\n}\n\n```", "```scala\npublic class Hello {\n  private final String name;\n  public Hello(String name) {\n    System.out.println(\"New instance with name: \" + name);\n    this.name = name;\n  }\n  public void sayHello() {\n    System.out.println(\"Hello, \" + name + \"!\");\n  }\n}\n\n```", "```scala\nclass HelloCity(CityName: String) {\n  def sayHelloToCity = println(\"Hello, \" + CityName + \"!\") \n}\n\n```", "```scala\nobject HelloCity { \n  // Factory method \n  def apply(CityName: String) = new Hello(CityName) \n}\n\n```", "```scala\npublic class HelloCity { \n  private final String CityName; \n  public HelloCity(String CityName) { \n    this.CityName = CityName; \n  }\n  public void sayHello() {\n    System.out.println(\"Hello, \" + CityName + \"!\"); \n  }\n  public static HelloCity apply(String CityName) { \n    return new Hello(CityName); \n  } \n}\n\n```", "```scala\nval hello1 = Hello.apply(\"Dublin\")\n\n```", "```scala\n val hello2 = Hello(\"Dublin\")\n\n```", "```scala\nclass SomeClass {\n  //First, to have to log for a class, you must initialize it\n  final static Logger log = LoggerFactory.getLogger(this.getClass());\n  ...\n  //For logging to be efficient, you must always check, if logging level for current message is enabled                \n  //BAD, you will waste execution time if the log level is an error, fatal, etc.\n  log.debug(\"Some debug message\");\n  ...\n  //GOOD, it saves execution time for something more useful\n  if (log.isDebugEnabled()) { log.debug(\"Some debug message\"); }\n  //BUT looks clunky, and it's tiresome to write this construct every time you want to log something.\n}\n\n```", "```scala\ntrait Logging {\n  lazy val log = LoggerFactory.getLogger(this.getClass.getName)     \n  //Let's start with info level...\n  ...\n  //Debug level here...\n  def debug() {\n    if (log.isDebugEnabled) log.info(s\"${msg}\")\n  }\n  def debug(msg: => Any, throwable: => Throwable) {\n    if (log.isDebugEnabled) log.info(s\"${msg}\", throwable)\n  }\n  ...\n  //Repeat it for all log levels you want to use\n}\n\n```", "```scala\nclass SomeClass extends Logging {\n  ...\n  //With logging trait, no need for declaring a logger manually for every class\n  //And now, your logging routine is either efficient and doesn't litter the code!\n\n  log.debug(\"Some debug message\")\n  ...\n}\n\n```", "```scala\ntrait Logging  {\n  override def toString = \"Logging \"\n}\nclass A extends Logging  {\n  override def toString = \"A->\" + super.toString\n}\ntrait B extends Logging  {\n  override def toString = \"B->\" + super.toString\n}\ntrait C extends Logging  {\n  override def toString = \"C->\" + super.toString\n}\nclass D extends A with B with C {\n  override def toString = \"D->\" + super.toString\n}\n\n```", "```scala\nobject HelloWorld {\n  def main(args: Array[String]){ \n    println(\"Hello, world!\")  \n  } \n}\n\n```", "```scala\nC:\\>scalac HelloWorld.scala\n C:\\>scala HelloWorld\n Hello, world!\n C:\\>\n\n```", "```scala\n> scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_121).\nType in expressions for evaluation. Or try :help.\nscala>\nscala> object HelloWorld {\n |   def main(args: Array[String]){\n |     println(\"Hello, world!\")\n |   }\n | }\ndefined object HelloWorld\nscala> HelloWorld.main(Array())\nHello, world!\nscala>\n\n```", "```scala\n> scalac HelloWorld.scala\n\n```", "```scala\n> scalac -d classes HelloWorld.scala\n\n```", "```scala\n$ scala HelloWorld\n\n```", "```scala\n$ scala -cp classes HelloWorld\n\n```", "```scala\n#!/usr/bin/env Scala \nobject HelloWorld extends App {  \n  println(\"Hello, world!\") \n}\nHelloWorld.main(args)\n\n```", "```scala\n./script.sh\n\n```", "```scala\n$ sudo chmod +x script.sh\n\n```"]